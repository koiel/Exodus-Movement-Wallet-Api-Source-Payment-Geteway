CREATE OR REPLACE PACKAGE BODY pkg_pre_etl_tools IS
   /*=================================================================================================
   
       ETL / Migration Utilities For Tabular to Tabular+JSON migration.
   
       Developed by Christian Leigh
       
       ***********************************************************************************************
       
       Copyright 2018 IHS Markit
   
       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
   
           http://www.apache.org/licenses/LICENSE-2.0
   
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.
       
       ************************************************************************************************
                
       PORTIONS OF THIS CODE - Specifically code, variables and constants relating to :-
       
                               fn_get_xml_to_json_stylesheet
                               fn_ref_cursor_to_json
                               fn_sql_to_json 
   
                 Are Copyright (c) 2006-2007, Doeke Zanstra
             
                 All rights reserved.
             
                 Redistribution and use in source and binary forms, with or without modification, 
                 are permitted provided that the following conditions are met:
             
                   * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
                   * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
                   * Neither the name of xml2json-xslt nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
                   
                   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
                   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
                   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
                   IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
                   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
                   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
                   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
                   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
                   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
                   THE POSSIBILITY OF SUCH DAMAGE.
   
       ************************************************************************************************
   
       Notes
       -----
       Package is stateful, but has no need for hot deployment and could benefit from custom caching.
       
                  
     =================================================================================================                  
   */

   scanner_exception EXCEPTION;
   PRAGMA EXCEPTION_INIT(scanner_exception, -20100);
   parser_exception EXCEPTION;
   PRAGMA EXCEPTION_INIT(parser_exception, -20101);
   --
   g_const_vc_tab_length CONSTANT PLS_INTEGER := 30000;
   --
   g_const_json_null_object CONSTANT VARCHAR2(20) := '{ }';
   g_const_json_handler     CONSTANT VARCHAR2(61) := 'pkg_pre_etl_tools.fn_make_json';
   g_const_json_handler_p0  CONSTANT VARCHAR2(30) := 'i_batch';
   g_const_json_handler_p1  CONSTANT VARCHAR2(30) := 'i_document';
   g_const_json_handler_p2  CONSTANT VARCHAR2(30) := 'i_nv_pair_tab';
   g_const_json_handler_p3  CONSTANT VARCHAR2(30) := 'i_staged_schema';
   g_const_json_handler_p4  CONSTANT VARCHAR2(30) := 'i_mr_group';
   g_const_json_handler_p5  CONSTANT VARCHAR2(30) := 'i_mig_group';
   g_const_json_handler_p6  CONSTANT VARCHAR2(30) := 'i_cache_key';
   g_const_json_handler_p7  CONSTANT VARCHAR2(30) := 'i_utility_field_1';
   g_const_json_handler_p8  CONSTANT VARCHAR2(30) := 'i_utility_field_2';
   g_const_json_handler_p9  CONSTANT VARCHAR2(30) := 'i_utility_field_3';
   g_const_json_handler_p10 CONSTANT VARCHAR2(30) := 'i_utility_field_4';
   g_const_json_handler_p11 CONSTANT VARCHAR2(30) := 'i_utility_field_5';
   g_const_json_handler_p12 CONSTANT VARCHAR2(30) := 'i_introspect_step';
   g_const_json_handler_p13 CONSTANT VARCHAR2(30) := 'i_smart_cache_key';
   g_const_json_handler_p14 CONSTANT VARCHAR2(30) := 'i_smart_cache_attrs';
   --
   g_const_usecase_dynamic_select CONSTANT PLS_INTEGER := 1;
   g_const_usecase_define_cols    CONSTANT PLS_INTEGER := 2;
   g_const_usecase_replace_vals   CONSTANT PLS_INTEGER := 3;
   --
   g_row_count PLS_INTEGER := 0;
   --
   g_tool_const_mapped   CONSTANT VARCHAR2(7) := ':MAPPED';
   g_tool_const_uf       CONSTANT VARCHAR2(15) := ':UTILITY_FIELD#';
   g_tool_const_uf_1     CONSTANT VARCHAR2(16) := ':UTILITY_FIELD#1';
   g_tool_const_uf_2     CONSTANT VARCHAR2(16) := ':UTILITY_FIELD#2';
   g_tool_const_uf_3     CONSTANT VARCHAR2(16) := ':UTILITY_FIELD#3';
   g_tool_const_uf_4     CONSTANT VARCHAR2(16) := ':UTILITY_FIELD#4';
   g_tool_const_uf_5     CONSTANT VARCHAR2(16) := ':UTILITY_FIELD#5';
   g_tool_const_lookup   CONSTANT VARCHAR2(7) := ':LOOKUP';
   g_tool_const_function CONSTANT VARCHAR2(9) := ':FUNCTION';
   g_tool_const_src      CONSTANT VARCHAR2(4) := ':SRC';
   g_tool_const_json     CONSTANT VARCHAR2(5) := ':JSON';
   g_tool_const_batch    CONSTANT VARCHAR2(6) := ':BATCH';
   --
   TYPE r_rec_find_swap IS RECORD(
       find_value pre_etl_find_swap.find_value%TYPE
      ,swap_value pre_etl_find_swap.swap_value%TYPE
      ,mig_group  pre_etl_find_swap.use_case%TYPE);

   TYPE r_rec_pem IS RECORD(
       table_name  pre_etl_mapped.table_name%TYPE
      ,column_name pre_etl_mapped.column_name%TYPE
      ,cnt         PLS_INTEGER);
   --
   TYPE t_tab_json_intra_clear IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(500);
   TYPE t_tab_json_frag IS TABLE OF VARCHAR2(32767) INDEX BY VARCHAR2(500);
   TYPE t_tab_output IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
   TYPE t_tab_sql IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
   TYPE t_tab_pem IS TABLE OF r_rec_pem INDEX BY VARCHAR2(200); /*index is relationship_group_id with mr_group */
   TYPE t_tab_find_swap IS TABLE OF r_rec_find_swap INDEX BY BINARY_INTEGER; /* find/swap cache */
   TYPE t_tab_ctx IS TABLE OF VARCHAR2(500) INDEX BY VARCHAR2(30);
   --
   -- Used for cache of json "documents by example" in fn_make_json.
   TYPE t_rec_pejl IS RECORD(
       json_line             pre_etl_json_lines.json_line%TYPE
      ,line_number           pre_etl_json_lines.line_number%TYPE
      ,relationship_group_id pre_etl_related_json_lines.relationship_group_id%TYPE
      ,mr_group              pre_etl_related_json_lines.mr_group%TYPE
      ,comment_type          pre_etl_comments.comment_type%TYPE
      ,last_line_verbatim_yn VARCHAR2(1));
   TYPE t_tab_pejl IS TABLE OF t_rec_pejl INDEX BY BINARY_INTEGER;
   TYPE t_tab_of_t_tab_pejl IS TABLE OF t_tab_pejl INDEX BY VARCHAR2(128);
   --
   g_tab_of_t_tab_pejl t_tab_of_t_tab_pejl;
   --
   g_cache_json_fragments t_tab_json_frag;
   g_json_intra_clear     t_tab_json_intra_clear;
   g_sql_array_debug      t_tab_sql;
   g_cache_pem            t_tab_pem;
   g_cache_find_swap      t_tab_find_swap;
   g_cache_ctx            t_tab_ctx;
   g_output               t_tab_output;
   g_run_context          VARCHAR2(50);
   --
   --

   TYPE t_tab_json_perf_cache IS TABLE OF VARCHAR2(32767) INDEX BY VARCHAR2(200);
   TYPE t_tab_cache_cycle IS TABLE OF VARCHAR2(200) INDEX BY BINARY_INTEGER;

   -- Caching for already made JSON (the simple cache).----------------------------------
   g_tab_json_perf_cache t_tab_json_perf_cache;
   g_json_cache_cycle    t_tab_cache_cycle;
   g_cache_position      PLS_INTEGER := 1;
   g_max_cache CONSTANT NUMBER := 100;
   --
   -- Caching for JSON (the smart cache).------------------------------------------------
   TYPE t_sc_rec_rows IS TABLE OF t_docbyexample_row INDEX BY PLS_INTEGER;
   TYPE t_sc_rec_origin_tab IS TABLE OF t_sc_rec_rows INDEX BY PLS_INTEGER;
   TYPE t_sc_rec_set_tab IS TABLE OF t_sc_rec_origin_tab INDEX BY PLS_INTEGER;
   TYPE t_tab_json_smart_cache IS TABLE OF t_sc_rec_set_tab INDEX BY VARCHAR2(200);
   -- There are 3 smart caches for the 3 different uses of the the fn_tab_func_doc_by_example 
   -- pipeline funtion in fn_make_json.  We're going for a table of tables.
   g_tab_json_smart_cache   t_tab_json_smart_cache;
   g_piped_line             PLS_INTEGER; -- Used in fn_smart_cache line caching.
   g_json_smart_cache_cycle t_tab_cache_cycle;
   g_smart_cache_position   PLS_INTEGER := 1;
   g_max_smart_cache CONSTANT NUMBER := 100;
   --
   --
   TYPE t_tab_nv_pos_cache IS TABLE OF NUMBER INDEX BY VARCHAR2(61);
   g_nv_pos_cache t_tab_nv_pos_cache;
   --
   -- Caching of work for replacing :MAPPED :MAPPED#x 
   TYPE t_tab IS TABLE OF PLS_INTEGER INDEX BY VARCHAR2(61);
   TYPE t_rec_mapped IS RECORD(
       mapped_cache  t_tab
      ,return_string VARCHAR2(32767));
   TYPE t_tab_mapped_cache IS TABLE OF t_rec_mapped INDEX BY VARCHAR2(200);
   g_tab_mapped_cache t_tab_mapped_cache;

   --
   -- Type for result cache function from PEC (for functions / lookups / arrays)
   TYPE t_rec_pec_fla IS RECORD(
       function_value VARCHAR2(32767)
      ,lookup_value   VARCHAR2(32767)
      ,array_value    VARCHAR2(32767));

   -- Types for the special poplists.
   TYPE t_rec IS RECORD(
       shown_value  VARCHAR2(2000)
      ,actual_value VARCHAR2(2000));
   TYPE t_popup_rec IS TABLE OF t_rec INDEX BY BINARY_INTEGER;
   TYPE t_popup_tab IS TABLE OF t_popup_rec INDEX BY BINARY_INTEGER;
   g_popup_tab t_popup_tab;

   ----------------------------------------------------------------------------

   PROCEDURE pr_dbms_output(i_line IN VARCHAR2) IS
   BEGIN
      g_output(g_output.COUNT + 1) := i_line || chr(10);
      -- 
      -- This SHOULD BE THE ONLY DBMS_OUTPUT IN THIS PACKAGE.
      dbms_output.put_line(i_line);
   END pr_dbms_output;
   ----------------------------------------------------------------------------

   FUNCTION fn_mapped RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':MAPPED';
   END fn_mapped;

   ----------------------------------------------------------------------------

   FUNCTION fn_uf RETURN VARCHAR2 result_cache IS
   BEGIN
      -- Any Utility Field
      RETURN ':UTILITY_FIELD#';
   END fn_uf;

   ----------------------------------------------------------------------------

   FUNCTION fn_uf_1 RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':UTILITY_FIELD#1';
   END fn_uf_1;

   ----------------------------------------------------------------------------

   FUNCTION fn_uf_2 RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':UTILITY_FIELD#2';
   END fn_uf_2;

   ----------------------------------------------------------------------------

   FUNCTION fn_uf_3 RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':UTILITY_FIELD#3';
   END fn_uf_3;

   ----------------------------------------------------------------------------

   FUNCTION fn_uf_4 RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':UTILITY_FIELD#4';
   END fn_uf_4;

   ----------------------------------------------------------------------------

   FUNCTION fn_uf_5 RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':UTILITY_FIELD#5';
   END fn_uf_5;

   ----------------------------------------------------------------------------

   FUNCTION fn_lookup RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':LOOKUP';
   END fn_lookup;

   ----------------------------------------------------------------------------

   FUNCTION fn_function RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':FUNCTION';
   END fn_function;

   ----------------------------------------------------------------------------

   FUNCTION fn_src RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':SRC';
   END fn_src;

   ----------------------------------------------------------------------------

   FUNCTION fn_json RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':JSON';
   END fn_json;

   ----------------------------------------------------------------------------

   FUNCTION fn_batch RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':BATCH';
   END fn_batch;

   ----------------------------------------------------------------------------

   FUNCTION fn_mck RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':MIG_CACHE_KEY';
   END fn_mck;

   ----------------------------------------------------------------------------

   FUNCTION fn_sck RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':MIG_SMART_CACHE_KEY';
   END fn_sck;

   ----------------------------------------------------------------------------

   FUNCTION fn_work_partitions RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':WORK_PARTITIONS';
   END fn_work_partitions;

   ----------------------------------------------------------------------------

   FUNCTION fn_thread_number RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN ':THREAD_NUMBER';
   END fn_thread_number;

   ----------------------------------------------------------------------------

   FUNCTION fn_lf(i_quantity IN NUMBER DEFAULT 1) RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN lpad(chr(10), i_quantity, chr(10));
   END fn_lf;

   ----------------------------------------------------------------------------

   FUNCTION fn_cut_clob_to_tab(i_clob IN CLOB)
      RETURN pkg_pre_etl_tools.t_vc_tab IS
      l_clob_idx   PLS_INTEGER;
      l_return_tab pkg_pre_etl_tools.t_vc_tab;
   BEGIN
      l_clob_idx := 1;
      WHILE TRUE
      LOOP
         l_return_tab(l_clob_idx) := substr(i_clob
                                           ,(((l_clob_idx - 1) *
                                            g_const_vc_tab_length) + 1)
                                           ,g_const_vc_tab_length);
         IF l_return_tab(l_clob_idx) IS NULL
         THEN
            l_return_tab.delete(l_clob_idx);
            EXIT;
         END IF;
         l_clob_idx := l_clob_idx + 1;
      END LOOP;
      -- 
      RETURN l_return_tab;
   END fn_cut_clob_to_tab;

   ----------------------------------------------------------------------------

   FUNCTION fn_max_mapped(i_comment IN VARCHAR2) RETURN NUMBER IS
      l_val        VARCHAR2(32000) := lower(i_comment);
      l_cnt        NUMBER := 1;
      l_pos        NUMBER;
      l_mapped     NUMBER;
      l_max_mapped NUMBER := 0;
   BEGIN
      IF instr(l_val, ':mapped#?') > 0
      THEN
         l_max_mapped := 0;
      ELSE
         WHILE TRUE
         LOOP
            l_pos := instr(l_val, ':mapped#', 1, l_cnt);
         
            IF l_pos > 0
            THEN
               l_mapped := to_number(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(substr(l_val
                                                                                   ,l_pos + 8
                                                                                   ,2)
                                                                            ,chr(10)
                                                                            ,NULL)
                                                                    ,' '
                                                                    ,NULL)
                                                            ,')'
                                                            ,NULL)
                                                    ,','
                                                    ,NULL)
                                            ,'|'
                                            ,NULL));
            ELSE
               IF nvl(l_mapped, 0) < 1
               THEN
                  l_pos := instr(l_val, ':mapped', 1, l_cnt);
                  IF l_pos > 0
                  THEN
                     l_max_mapped := 1;
                  END IF;
               END IF;
               EXIT;
            END IF;
         
            IF l_mapped > l_max_mapped
            THEN
               l_max_mapped := l_mapped;
            END IF;
            --
            l_cnt := l_cnt + 1;
         END LOOP;
      END IF;
   
      RETURN l_max_mapped;
   END fn_max_mapped;
   ----------------------------------------------------------------------------

   FUNCTION fn_validate_mapping(i_context IN VARCHAR2) RETURN VARCHAR2 IS
      l_validation_message       VARCHAR2(32767) := NULL;
      l_validation_too_long_bool BOOLEAN := FALSE;
      l_quit_bool                BOOLEAN;
      PROCEDURE pr_sql_parse_test
      (
         i_sql                 IN VARCHAR2
        ,i_mr_group            IN VARCHAR2
        ,i_document_name       IN VARCHAR2
        ,i_line_number         IN NUMBER
        ,i_type                IN VARCHAR2
        ,io_validation_message IN OUT NOCOPY VARCHAR2
        ,o_quit                OUT BOOLEAN
      ) IS
         l_dbms_sql_cursor INTEGER;
         l_sql             VARCHAR2(32000) := regexp_replace(REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => pkg_pre_etl_tools.fn_replace_dollar_dollar(i_string                       => pkg_pre_etl_tools.fn_contextualize(i_sql
                                                                                                                                                                                                                                               ,i_context)
                                                                                                                                                                          ,i_remove_external_reftags_bool => FALSE)
                                                                                                                ,i_keyword   => g_tool_const_json)
                                                                    ,g_tool_const_json
                                                                    ,NULL)
                                                            ,'<!\S[^!>]+\S{2}'
                                                            ,':1');
      BEGIN
         o_quit := FALSE;
         IF upper(l_sql) LIKE '%' || g_tool_const_src || '%'
         THEN
            /* If a function or lookup contains :SRC (it depends on where and when it could get used - we can't validate that */
            NULL;
         ELSE
            l_dbms_sql_cursor := dbms_sql.open_cursor;
            dbms_sql.parse(l_dbms_sql_cursor, l_sql, dbms_sql.native);
            dbms_sql.close_cursor(l_dbms_sql_cursor);
         END IF;
      EXCEPTION
         WHEN OTHERS THEN
            dbms_sql.close_cursor(l_dbms_sql_cursor);
            io_validation_message := io_validation_message ||
                                     rpad(i_mr_group, 26, ' ') ||
                                     rpad(substr(i_document_name, 1, 40) ||
                                          (CASE
                                              WHEN substr(i_document_name, 41, 1) IS NOT NULL THEN
                                               '...'
                                           END)
                                         ,43
                                         ,' ') || '  Line : ' ||
                                     rpad(to_char(i_line_number), 4, ' ') || ' ' ||
                                     'Cannot parse.  Check ' || i_type ||
                                     chr(10);
            IF length(io_validation_message) > 31000
            THEN
               io_validation_message := io_validation_message ||
                                        '...';
               o_quit                := TRUE;
            END IF;
      END pr_sql_parse_test;
   BEGIN
      FOR i_buf IN (SELECT ilv.mr_group
                          ,ilv.document_name
                          ,ilv.json_line
                          ,ilv.line_number
                          ,(CASE
                              WHEN mapped_to_count >
                                   maps_specified_in_comment THEN
                               (CASE
                                  WHEN combined_comment IS NULL THEN
                                   '*ERROR* - Over mapped without function, lookup or array'
                                  ELSE
                                   '*WARNING* - Over mapped'
                               END)
                              WHEN maps_specified_in_comment >
                                   mapped_to_count THEN
                               '*ERROR* - Under mapped'
                              WHEN has_mapped_hash_number = 'TRUE'
                                   AND mapped_to_count = 1
                                   AND maps_specified_in_comment =
                                   mapped_to_count THEN
                               '*ERROR* - Single mapped function, lookup or array has' ||
                               chr(10) || lpad(' ', 79 + 14, ' ') ||
                               'a :MAPPED#n value instead of simple :MAPPED'
                              ELSE
                               NULL
                           END) mapping_status
                      FROM (SELECT perjl.mr_group
                                  ,pejl.document_name
                                  ,pejl.json_line
                                  ,pejl.line_number
                                  ,(SELECT COUNT(*)
                                      FROM pre_etl_mapped pem
                                     WHERE pem.mr_group =
                                           perjl.mr_group
                                       AND pem.relationship_group_id =
                                           perjl.relationship_group_id) AS mapped_to_count
                                  ,pkg_pre_etl_tools.fn_max_mapped(i_comment => pec_a.comments || ' ' ||
                                                                                pec_f.comments || ' ' ||
                                                                                pec_l.comments || ' ') AS maps_specified_in_comment
                                  ,pec_a.comments || pec_f.comments ||
                                   pec_l.comments AS combined_comment
                                  ,CASE
                                      WHEN instr(pec_a.comments || ' ' ||
                                                 pec_f.comments || ' ' ||
                                                 pec_l.comments
                                                ,':MAPPED#') > 0 THEN
                                       'TRUE'
                                      ELSE
                                       'FALSE'
                                   END AS has_mapped_hash_number
                              FROM pre_etl_json_lines pejl
                              JOIN pre_etl_related_json_lines perjl
                                ON (perjl.document_name =
                                   pejl.document_name AND
                                   perjl.line_number =
                                   pejl.line_number)
                              JOIN pre_etl_doc_valid_contexts pedvc
                                ON (pedvc.document_name =
                                   perjl.document_name AND
                                   nvl(pedvc.context_name, i_context) =
                                   i_context)
                              LEFT JOIN pre_etl_comments pec_a
                                ON (pec_a.mr_group = perjl.mr_group AND
                                   pec_a.relationship_group_id =
                                   perjl.relationship_group_id AND
                                   pec_a.comment_type IN ('A', 'V'))
                              LEFT JOIN pre_etl_comments pec_f
                                ON (pec_f.mr_group = perjl.mr_group AND
                                   pec_f.relationship_group_id =
                                   perjl.relationship_group_id AND
                                   pec_f.comment_type = 'F')
                              LEFT JOIN pre_etl_comments pec_l
                                ON (pec_l.mr_group = perjl.mr_group AND
                                   pec_l.relationship_group_id =
                                   perjl.relationship_group_id AND
                                   pec_l.comment_type = 'L')) ilv
                     WHERE (maps_specified_in_comment > 0 AND
                           maps_specified_in_comment !=
                           mapped_to_count)
                        OR (mapped_to_count > 1 AND
                           combined_comment IS NULL)
                        OR (has_mapped_hash_number = 'TRUE' AND
                           mapped_to_count = 1 AND maps_specified_in_comment =
                           mapped_to_count))
      LOOP
         l_validation_message := l_validation_message ||
                                 rpad(i_buf.mr_group, 26, ' ') ||
                                 rpad(substr(i_buf.document_name, 1, 40) ||
                                      (CASE
                                          WHEN substr(i_buf.document_name, 41, 1) IS NOT NULL THEN
                                           '...'
                                       END)
                                     ,43
                                     ,' ') || '  Line : ' ||
                                 rpad(to_char(i_buf.line_number), 4, ' ') || ' ' ||
                                 i_buf.mapping_status || chr(10);
         IF length(l_validation_message) > 31000
         THEN
            l_validation_message       := l_validation_message ||
                                          '...';
            l_validation_too_long_bool := TRUE;
            EXIT;
         END IF;
      END LOOP;
   
      IF NOT l_validation_too_long_bool
      THEN
         FOR i_buf IN (SELECT *
                         FROM (SELECT perjl.mr_group
                                     ,pejl.document_name
                                     ,pejl.json_line
                                     ,pejl.line_number
                                     ,pec_a.comments     AS comment_array
                                     ,pec_f.comments     AS comment_function
                                     ,pec_l.comments     AS comment_lookup
                                 FROM pre_etl_json_lines pejl
                                 JOIN pre_etl_related_json_lines perjl
                                   ON (perjl.document_name =
                                      pejl.document_name AND
                                      perjl.line_number =
                                      pejl.line_number)
                                 JOIN pre_etl_doc_valid_contexts pedvc
                                   ON (pedvc.document_name =
                                      perjl.document_name AND
                                      nvl(pedvc.context_name
                                          ,i_context) = i_context)
                                 LEFT JOIN pre_etl_comments pec_a
                                   ON (pec_a.mr_group = perjl.mr_group AND
                                      pec_a.relationship_group_id =
                                      perjl.relationship_group_id AND
                                      pec_a.comment_type IN ('A', 'V'))
                                 LEFT JOIN pre_etl_comments pec_f
                                   ON (pec_f.mr_group = perjl.mr_group AND
                                      pec_f.relationship_group_id =
                                      perjl.relationship_group_id AND
                                      pec_f.comment_type = 'F')
                                 LEFT JOIN pre_etl_comments pec_l
                                   ON (pec_l.mr_group = perjl.mr_group AND
                                      pec_l.relationship_group_id =
                                      perjl.relationship_group_id AND
                                      pec_l.comment_type = 'L')) ilv)
         LOOP
            IF substr(i_buf.comment_function, 1, 1) = '='
            THEN
               pr_sql_parse_test(i_sql                 => 'SELECT ' ||
                                                          substr(i_buf.comment_function
                                                                ,2) ||
                                                          ' FROM DUAL'
                                ,i_mr_group            => i_buf.mr_group
                                ,i_document_name       => i_buf.document_name
                                ,i_line_number         => i_buf.line_number
                                ,i_type                => 'function'
                                ,io_validation_message => l_validation_message
                                ,o_quit                => l_quit_bool);
            END IF;
            EXIT WHEN l_quit_bool = TRUE;
            --
            --
            IF upper(substr(i_buf.comment_array, 1, 6)) = 'SELECT'
               OR upper(substr(i_buf.comment_array, 1, 4)) = 'WITH'
            THEN
               pr_sql_parse_test(i_sql                 => i_buf.comment_array
                                ,i_mr_group            => i_buf.mr_group
                                ,i_document_name       => i_buf.document_name
                                ,i_line_number         => i_buf.line_number
                                ,i_type                => 'array'
                                ,io_validation_message => l_validation_message
                                ,o_quit                => l_quit_bool);
            END IF;
            EXIT WHEN l_quit_bool = TRUE;
            --
            --
            IF upper(substr(i_buf.comment_lookup, 1, 6)) = 'SELECT'
               OR upper(substr(i_buf.comment_lookup, 1, 4)) = 'WITH'
            THEN
               pr_sql_parse_test(i_sql                 => i_buf.comment_lookup
                                ,i_mr_group            => i_buf.mr_group
                                ,i_document_name       => i_buf.document_name
                                ,i_line_number         => i_buf.line_number
                                ,i_type                => 'array'
                                ,io_validation_message => l_validation_message
                                ,o_quit                => l_quit_bool);
            END IF;
            EXIT WHEN l_quit_bool = TRUE;
            --
         --
         END LOOP;
      END IF;
   
      --
      RETURN l_validation_message;
   END fn_validate_mapping;

   ----------------------------------------------------------------------------

   FUNCTION fn_recase_colon_commands(i_string IN VARCHAR2)
      RETURN VARCHAR2 IS
      l_recase_string VARCHAR2(32767) := i_string;
   BEGIN
   
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_mapped);
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_lookup);
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_function);
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_src);
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_json);
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_batch);
      l_recase_string := pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_recase_string
                                                                    ,i_keyword   => pkg_pre_etl_tools.g_tool_const_uf);
      RETURN l_recase_string;
   END fn_recase_colon_commands;

   ----------------------------------------------------------------------------

   FUNCTION fn_bump_mapped_numbers
   (
      i_string                 IN VARCHAR2
     ,i_direction              IN VARCHAR2
     ,i_start_point            IN NUMBER
     ,i_previously_single_bool IN BOOLEAN
   ) RETURN VARCHAR2 IS
      l_replace_string        VARCHAR2(32767) := i_string;
      l_skip_renumbering_bool BOOLEAN := FALSE;
   BEGIN
      IF i_direction NOT IN ('UP', 'DOWN')
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools : fn_bump_mapped_numbers : i_direction must be UP or DOWN. ');
      END IF;
      IF i_direction = 'DOWN'
         AND i_start_point <= 0
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools : fn_bump_mapped_numbers : Cannot bump down from here. ');
      END IF;
      IF i_direction = 'UP'
         AND i_start_point >= 20
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools : fn_bump_mapped_numbers : Cannot bump up from here. ');
      END IF;
      IF i_direction = 'UP'
         AND i_start_point < 1
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools : fn_bump_mapped_numbers : Cannot start at less than 1. ');
      END IF;
      --
      IF i_direction = 'UP'
         AND i_previously_single_bool
      THEN
         IF instr(REPLACE(l_replace_string, ':MAPPED', ':MAPPED#1')
                 ,':MAPPED#1#') = 0
         THEN
            l_replace_string := REPLACE(l_replace_string
                                       ,':MAPPED'
                                       ,':MAPPED#1');
         ELSE
            l_skip_renumbering_bool := TRUE;
         END IF;
      END IF;
      --
      IF NOT l_skip_renumbering_bool
      THEN
         FOR i IN REVERSE 0 .. 20
         LOOP
            IF i = 0
               AND i_direction = 'UP'
               AND i_start_point = 1
            THEN
               l_replace_string := REPLACE(l_replace_string
                                          ,':MAPPED'
                                          ,':mapped#2');
            ELSE
               IF i >= i_start_point
               THEN
                  -- NOTE : The deliberate use of lowercase to exclude that from any subsequent replace
                  --        The fn_recase_colon_commands will re-uppercase it.
                  l_replace_string := REPLACE(l_replace_string
                                             ,':MAPPED#' || to_char(i)
                                             ,(CASE i_direction
                                                 WHEN 'UP' THEN
                                                  ':mapped#' || to_char(i + 1)
                                                 ELSE
                                                  (CASE
                                                     WHEN i_direction = 'DOWN'
                                                          AND i = 1
                                                          AND i_previously_single_bool THEN
                                                      ':mapped'
                                                     WHEN i_direction = 'DOWN'
                                                          AND i = i_start_point THEN
                                                      ':mapped#?'
                                                     ELSE
                                                      ':mapped#' || to_char(i - 1)
                                                  END)
                                              END));
               END IF;
            END IF;
         END LOOP;
      END IF;
      --  
      --
      RETURN fn_recase_colon_commands(i_string => l_replace_string);
   END fn_bump_mapped_numbers;

   ----------------------------------------------------------------------------
   -- Fwd declaration...
   PROCEDURE pr_replace_clob
   (
      io_subject IN OUT CLOB
     ,i_replace  IN VARCHAR2
     ,i_value    IN CLOB
   );
   -- Fwd declaration...   
   PROCEDURE pr_replace_varchar2
   (
      io_subject IN OUT VARCHAR2
     ,i_replace  IN VARCHAR2
     ,i_value    IN VARCHAR2
   );

   PROCEDURE pr_dbms_output_big(i_clob IN CLOB) IS
      l_ioffset PLS_INTEGER := 1;
      l_iamount PLS_INTEGER := 100;
   BEGIN
      WHILE l_ioffset < length(i_clob)
      LOOP
         pr_dbms_output(substr(i_clob, l_ioffset, l_iamount));
         l_ioffset := l_ioffset + l_iamount;
         l_iamount := least(100, length(i_clob) - l_iamount);
      END LOOP;
   END pr_dbms_output_big;

   ----------------------------------------------------------------------------

   FUNCTION fn_is_mig_local(i_table_name IN VARCHAR2) RETURN BOOLEAN IS
      CURSOR cur_iml(c_table_name IN VARCHAR2) IS
         SELECT NULL
           FROM user_tables ut
          WHERE ut.table_name = upper(c_table_name);
      cur_iml_buf cur_iml%ROWTYPE;
      --
      CURSOR cur_pedt(c_table_name IN VARCHAR2) IS
         SELECT NULL
           FROM pre_etl_db2_tables pedt
          WHERE pedt.table_name = upper(c_table_name)
            AND pedt.local_hash IS NULL;
      cur_pedt_buf cur_pedt%ROWTYPE;
      --
      l_exists_bool BOOLEAN;
      l_return_bool BOOLEAN;
   BEGIN
      OPEN cur_iml(c_table_name => i_table_name);
      FETCH cur_iml
         INTO cur_iml_buf;
      l_exists_bool := cur_iml%FOUND;
      CLOSE cur_iml;
      --
      IF l_exists_bool
      THEN
         OPEN cur_pedt(c_table_name => i_table_name);
         FETCH cur_pedt
            INTO cur_pedt_buf;
         l_exists_bool := cur_pedt%FOUND;
         CLOSE cur_pedt;
         -- 
         IF l_exists_bool
         THEN
            l_return_bool := FALSE;
         ELSE
            l_return_bool := TRUE;
         END IF;
      ELSE
         l_return_bool := FALSE;
      END IF;
      --
      RETURN l_return_bool;
   END fn_is_mig_local;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_hash_from_real_local(i_table_name IN VARCHAR2)
      RETURN VARCHAR2 IS
      l_clob CLOB;
   BEGIN
      FOR i_buf IN (SELECT utc.table_name AS table_name
                          ,(utc.column_id - 1) column_pos
                          ,utc.column_name AS column_name
                          ,(CASE
                              WHEN utc.data_type LIKE 'TIMESTAMP%' THEN
                               'TIMESTAMP'
                              ELSE
                               utc.data_type
                           END) AS column_type
                          ,ucc.comments AS comments
                      FROM user_tab_cols utc
                      LEFT JOIN user_col_comments ucc
                        ON (ucc.table_name = utc.table_name AND
                           ucc.column_name = utc.column_name)
                     WHERE utc.table_name = upper(i_table_name)
                    UNION
                    SELECT upper(i_table_name)
                          ,-1
                          ,'<Not Mapped>'
                          ,'0'
                          ,'JSON needs Mapping...'
                      FROM dual
                     ORDER BY 2)
      LOOP
         l_clob := l_clob || i_buf.table_name || ',' ||
                   i_buf.column_pos || ',' || i_buf.column_name || ',' ||
                   i_buf.column_type || ',' || i_buf.comments;
      END LOOP;
      --
      RETURN fn_get_hash_for_clob(i_clob => l_clob);
   END fn_get_hash_from_real_local;

   ----------------------------------------------------------------------------

   FUNCTION fn_has_mig_local_def_changed(i_table_name IN VARCHAR2)
      RETURN BOOLEAN IS
      l_clob   CLOB;
      l_hash_1 VARCHAR2(50);
      l_hash_2 VARCHAR2(50);
   BEGIN
      l_hash_1 := fn_get_hash_from_real_local(i_table_name => i_table_name);
      --
      FOR i_buf IN (SELECT pedc.table_name
                          ,pedc.column_pos
                          ,pedc.column_name
                          ,pedc.column_type
                          ,pedc.comments
                      FROM pre_etl_db2_columns pedc
                     WHERE pedc.table_name = upper(i_table_name)
                     ORDER BY 2)
      LOOP
         l_clob := l_clob || i_buf.table_name || ',' ||
                   i_buf.column_pos || ',' || i_buf.column_name || ',' ||
                   i_buf.column_type || ',' || i_buf.comments;
      END LOOP;
      --
      l_hash_2 := fn_get_hash_for_clob(i_clob => l_clob);
      --
      IF l_hash_1 != l_hash_2
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   
   END fn_has_mig_local_def_changed;

   ----------------------------------------------------------------------------

   FUNCTION fn_mig_local_exist(i_table_name IN VARCHAR2) RETURN BOOLEAN IS
      CURSOR cur_pedt(c_table_name IN VARCHAR2) IS
         SELECT NULL
           FROM pre_etl_db2_tables pedt
          WHERE pedt.table_name = c_table_name
            AND pedt.local_hash IS NOT NULL;
      cur_pedt_buf cur_pedt%ROWTYPE;
      --
      l_exists_bool BOOLEAN;
   BEGIN
      OPEN cur_pedt(c_table_name => i_table_name);
      FETCH cur_pedt
         INTO cur_pedt_buf;
      l_exists_bool := cur_pedt%FOUND;
      CLOSE cur_pedt;
      --
      RETURN l_exists_bool;
   END fn_mig_local_exist;

   ----------------------------------------------------------------------------

   FUNCTION fn_mapping_is_valid
   (
      i_relationship_group_id IN NUMBER
     ,i_mr_group              IN VARCHAR2
   ) RETURN BOOLEAN IS
      CURSOR cur_mv
      (
         c_relationship_group_id IN NUMBER
        ,c_mr_group              IN VARCHAR2
      ) IS
         SELECT MIN(CASE
                       WHEN pedc.column_name IS NULL
                            OR (utc.column_name IS NULL AND
                            pedt.table_name IS NOT NULL) THEN
                        'FALSE'
                       ELSE
                        'TRUE'
                    END) is_mapping_valid
           FROM pre_etl_mapped pem
           LEFT JOIN pre_etl_db2_columns pedc
             ON (pedc.table_name = pem.table_name AND
                pedc.column_name = pem.column_name)
           LEFT JOIN user_tab_cols utc
             ON (utc.table_name = pem.table_name AND
                utc.column_name = pem.column_name)
           LEFT JOIN pre_etl_db2_tables pedt
             ON (pedt.table_name = pem.table_name AND
                pedt.local_hash IS NOT NULL)
          WHERE pem.relationship_group_id = c_relationship_group_id
            AND pem.mr_group = c_mr_group;
      cur_mv_buf cur_mv%ROWTYPE;
   
   BEGIN
      OPEN cur_mv(c_relationship_group_id => i_relationship_group_id
                 ,c_mr_group              => i_mr_group);
      FETCH cur_mv
         INTO cur_mv_buf;
      CLOSE cur_mv;
      -- 
      RETURN(CASE cur_mv_buf.is_mapping_valid WHEN 'TRUE' THEN TRUE ELSE
             FALSE END);
   END fn_mapping_is_valid;

   ----------------------------------------------------------------------------

   PROCEDURE pr_recreate_mig_local(i_table_name IN VARCHAR2) IS
      l_hash VARCHAR2(50) := fn_get_hash_from_real_local(i_table_name => i_table_name);
   BEGIN
   
      DELETE FROM pre_etl_db2_columns pedc
       WHERE pedc.table_name = upper(i_table_name);
   
      DELETE FROM pre_etl_db2_tables pedt
       WHERE pedt.table_name = upper(i_table_name);
   
      INSERT INTO pre_etl_db2_tables
         (table_name
         ,markit_comment
         ,description
         ,local_hash
         ,tableset_name)
      VALUES
         (upper(i_table_name)
         ,NULL
         ,'Local Table :' || i_table_name
         ,l_hash
         ,'LOCAL');
   
      INSERT INTO pre_etl_db2_columns
         (table_name
         ,column_pos
         ,column_name
         ,column_type
         ,column_length
         ,comments
         ,tableset_name)
         SELECT utc.table_name AS table_name
               ,(utc.column_id - 1) column_pos
               ,utc.column_name AS column_name
               ,(CASE
                   WHEN utc.data_type LIKE 'TIMESTAMP%' THEN
                    'TIMESTAMP'
                   ELSE
                    utc.data_type
                END) AS column_type
               ,(CASE utc.data_type
                   WHEN 'CHAR' THEN
                    utc.char_length
                   WHEN 'VARCHAR2' THEN
                    utc.char_length
                   ELSE
                    utc.data_length
                END) AS column_length
               ,ucc.comments AS comments
               ,'LOCAL'
           FROM user_tab_cols utc
           LEFT JOIN user_col_comments ucc
             ON (ucc.table_name = utc.table_name AND
                ucc.column_name = utc.column_name)
          WHERE utc.table_name = upper(i_table_name)
            AND utc.table_name NOT LIKE 'BIN$%'
         UNION
         SELECT upper(i_table_name)
               ,-1
               ,'<Not Mapped>'
               ,'0'
               ,0
               ,'JSON needs Mapping...'
               ,'LOCAL'
           FROM dual
          ORDER BY 2;
   
      COMMIT;
   
   END pr_recreate_mig_local;

   ----------------------------------------------------------------------------

   PROCEDURE pr_cleanup_local_mappings(i_table_name IN VARCHAR2) IS
      CURSOR cur_pedt(c_table_name IN VARCHAR2) IS
         SELECT NULL
           FROM pre_etl_db2_tables pedt
          WHERE pedt.table_name = upper(c_table_name)
            AND pedt.local_hash IS NOT NULL;
      cur_pedt_buf  cur_pedt%ROWTYPE;
      l_exists_bool BOOLEAN;
   BEGIN
      OPEN cur_pedt(c_table_name => i_table_name);
      FETCH cur_pedt
         INTO cur_pedt_buf;
      l_exists_bool := cur_pedt%FOUND;
      CLOSE cur_pedt;
      -- Only do this if its a "local" table.
      IF l_exists_bool
      THEN
         FOR i_buf IN (SELECT pem.*
                         FROM pre_etl_mapped pem
                         LEFT JOIN pre_etl_db2_columns pedc
                           ON (pedc.table_name = pem.table_name AND
                              pedc.column_name = pem.column_name)
                        WHERE pem.table_name = i_table_name
                          AND pedc.column_name IS NULL)
         LOOP
            DELETE FROM pre_etl_mapped pem
             WHERE pem.table_name = i_buf.table_name
               AND pem.column_name = i_buf.column_name;
         END LOOP;
      END IF;
      --
      COMMIT;
   END pr_cleanup_local_mappings;

   ----------------------------------------------------------------------------

   PROCEDURE ex_raise_nested_lk_fn(i_error_text IN VARCHAR2) IS
   BEGIN
      raise_application_error(-20000
                             ,i_error_text ||
                              ' : Lookup uses a function and the function uses the lookup.');
   END ex_raise_nested_lk_fn;

   ----------------------------------------------------------------------------

   PROCEDURE ex_cannot_choose_fn_or_lk IS
   BEGIN
      raise_application_error(-20000
                             ,'Cannot determine which to use... lookup, function (or in the case of json the array).');
   END ex_cannot_choose_fn_or_lk;

   ----------------------------------------------------------------------------

   FUNCTION fn_rep_ctx_with_lit_from_cache(i_sql IN VARCHAR2)
      RETURN VARCHAR2 IS
      l_nth PLS_INTEGER := 1;
      l_cnt PLS_INTEGER := 0;
      l_pos PLS_INTEGER := 0;
      l_key VARCHAR2(30);
      TYPE t_rep_rec IS RECORD(
          st  PLS_INTEGER
         ,ctx VARCHAR2(32767)
         ,en  PLS_INTEGER
         ,rep VARCHAR2(32767));
      TYPE t_rep IS TABLE OF t_rep_rec INDEX BY BINARY_INTEGER;
   
      l_rep       t_rep;
      l_sql       VARCHAR2(32767) := i_sql;
      l_sql_upper VARCHAR2(32767) := upper(l_sql);
   BEGIN
      l_cnt := 1;
      WHILE TRUE
      LOOP
         l_pos := instr(l_sql_upper
                       ,'PKG_PRE_ETL_TOOLS.FN_GET_CONTEXT_VALUE'
                       ,1
                       ,l_nth);
      
         l_nth := l_nth + 1;
         IF l_pos = 0
         THEN
            EXIT;
         END IF;
         l_key := substr(l_sql_upper
                        ,instr(l_sql_upper, chr(39), l_pos, 1) + 1
                        ,(instr(l_sql_upper, chr(39), l_pos, 2)) - 2 -
                         instr(l_sql_upper, chr(39), l_pos, 1) + 1);
         IF g_cache_ctx.EXISTS(l_key)
         THEN
            l_rep(l_cnt).st := l_pos;
            l_rep(l_cnt).ctx := chr(39) || g_cache_ctx(l_key) ||
                                chr(39);
            l_rep(l_cnt).en := instr(l_sql_upper, ')', l_pos, 1) + 1;
            l_rep(l_cnt).rep := substr(l_sql
                                      ,l_rep(l_cnt).st
                                      ,l_rep(l_cnt)
                                       .en - l_rep(l_cnt).st);
            l_cnt := l_cnt + 1;
         END IF;
      END LOOP;
      --
      IF l_rep.COUNT > 0
      THEN
         FOR i IN l_rep.FIRST .. l_rep.LAST
         LOOP
            l_sql := REPLACE(l_sql, l_rep(i).rep, l_rep(i).ctx);
         END LOOP;
      END IF;
      --
      RETURN l_sql;
   END fn_rep_ctx_with_lit_from_cache;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_context_value
   (
      i_attr                      IN VARCHAR2
     ,i_fail_if_no_run_context_yn IN VARCHAR2 DEFAULT 'Y'
   ) RETURN VARCHAR2
      PARALLEL_ENABLE IS
      l_return VARCHAR2(32767);
   BEGIN
      l_return := sys_context(namespace => 'MIGRATION_CONTEXT'
                             ,attribute => upper(i_attr));
      IF i_attr = migration_run_framework.fn_ctx_run_context
         AND l_return IS NULL
         AND nvl(i_fail_if_no_run_context_yn, 'Y') = 'Y'
      THEN
         raise_application_error(-20999
                                ,'There is no RUN CONTEXT setup - You might be running the migration step standalone.  Use pkg_pre_etl_tools.pr_set_context(i_attr  => migration_run_framework.fn_ctx_run_context,i_value => ? )');
      END IF;
      RETURN l_return;
   END fn_get_context_value;

   ----------------------------------------------------------------------------

   PROCEDURE pr_destroy_context_attr(i_attr IN VARCHAR2) IS
   BEGIN
      dbms_session.clear_context(namespace => 'MIGRATION_CONTEXT'
                                ,attribute => i_attr);
   END pr_destroy_context_attr;

   ----------------------------------------------------------------------------

   PROCEDURE pr_destroy_context IS
   BEGIN
      dbms_session.clear_context(namespace => 'MIGRATION_CONTEXT');
   END pr_destroy_context;

   ----------------------------------------------------------------------------

   PROCEDURE pr_set_context
   (
      i_attr  IN VARCHAR2
     ,i_value IN VARCHAR2
   ) IS
   BEGIN
      dbms_session.set_context(namespace => 'MIGRATION_CONTEXT'
                              ,attribute => upper(i_attr)
                              ,VALUE     => i_value);
   END pr_set_context;

   ----------------------------------------------------------------------------

   FUNCTION fn_set_context_and_passthru
   (
      i_attr  IN VARCHAR2
     ,i_value IN VARCHAR2
   ) RETURN VARCHAR2 IS
   BEGIN
      dbms_session.set_context(namespace => 'MIGRATION_CONTEXT'
                              ,attribute => upper(i_attr)
                              ,VALUE     => i_value);
      RETURN i_value;
   END fn_set_context_and_passthru;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_hash_for_mig_name
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN RAW IS
      l_clob CLOB;
   BEGIN
      FOR i_buf IN (SELECT '"' || pemh.staged_schema || '",' || '"' ||
                           pemd.migration_document || '",' || '"' ||
                           pemd.order_of_exec || '",' || '"' ||
                           pemd.trigger_sql || '",' || '"' ||
                           perjl.document_name || '",' || '"' ||
                           perjl.line_number || '",' || '"' ||
                           perjl.relationship_group_id || '",' || '"' ||
                           perjl.mr_group || '",' || '"' ||
                           pec.comment_type || '",' || '"' ||
                           pec.comments || '",' || '"' ||
                           pem.table_name || '",' || '"' ||
                           pem.column_name || '"' AS hash_line
                      FROM pre_etl_migration_header pemh
                      JOIN pre_etl_migration_detail pemd
                        ON (pemd.migration_name = pemh.migration_name)
                      JOIN pre_etl_related_json_lines perjl
                        ON (perjl.document_name =
                           pemd.migration_document AND
                           perjl.mr_group = pemh.mr_group_to_use)
                      LEFT JOIN pre_etl_comments pec
                        ON (pec.relationship_group_id =
                           perjl.relationship_group_id AND
                           pec.mr_group = perjl.mr_group AND
                           (substr(CAST(pec.comments AS
                                         VARCHAR2(32000))
                                   ,1
                                   ,1) = '=' OR
                           upper(substr(CAST(pec.comments AS
                                               VARCHAR2(32000))
                                         ,1
                                         ,6)) = 'SELECT' OR
                           upper(substr(CAST(pec.comments AS
                                               VARCHAR2(32000))
                                         ,1
                                         ,4)) = 'WITH'))
                      LEFT JOIN pre_etl_mapped pem
                        ON (pem.relationship_group_id =
                           perjl.relationship_group_id AND
                           pem.mr_group = perjl.mr_group)
                     WHERE pemh.migration_group = i_migration_group
                       AND pemh.migration_name = i_migration_name
                     ORDER BY pemh.staged_schema
                             ,pemd.migration_document
                             ,pemd.order_of_exec
                             ,pemd.trigger_sql
                             ,perjl.document_name
                             ,perjl.line_number
                             ,perjl.mr_group
                             ,perjl.relationship_group_id
                             ,pec.comment_type
                             ,CAST(pec.comments AS VARCHAR2(32000))
                             ,pem.table_name
                             ,pem.column_name)
      LOOP
         l_clob := l_clob || i_buf.hash_line;
      END LOOP;
      --
      IF l_clob IS NULL
      THEN
         RETURN NULL;
      ELSE
         RETURN fn_get_hash_for_clob(i_clob => l_clob);
      END IF;
   END fn_get_hash_for_mig_name;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_hash_for_clob(i_clob IN CLOB) RETURN RAW
      PARALLEL_ENABLE IS
   BEGIN
      IF i_clob IS NULL
      THEN
         RETURN NULL;
      ELSE
         RETURN dbms_crypto.hash(i_clob
                                ,to_number(dbms_crypto.hash_md5));
      END IF;
   END fn_get_hash_for_clob;

   ----------------------------------------------------------------------------

   FUNCTION pre_etl_fn_exec(i_statement IN VARCHAR2) RETURN VARCHAR2 IS
      -- Ref Cursor
      TYPE typ_refcursor IS REF CURSOR; -- define weak REF CURSOR type
      cur_rc typ_refcursor; -- declare cursor variable
      --
      l_return VARCHAR2(2000);
   BEGIN
      IF upper(substr(i_statement, 1, 6)) != 'SELECT'
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools.pre_etl_fn_exec : Bad Statement.');
      END IF;
      OPEN cur_rc FOR i_statement;
      FETCH cur_rc
         INTO l_return;
      CLOSE cur_rc;
      RETURN l_return;
   END pre_etl_fn_exec;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_attribute
   (
      i_line                       IN VARCHAR2
     ,i_suppress_get_col_name_bool IN BOOLEAN DEFAULT FALSE
   ) RETURN VARCHAR2 IS
      l_result VARCHAR2(2000);
   BEGIN
      l_result := TRIM(i_line);
      l_result := substr(l_result
                        ,instr(l_result, '"', 1, 1) + 1
                        ,instr(l_result, '"', 1, 2) -
                         instr(l_result, '"', 1, 1) - 1);
      --
      IF NOT i_suppress_get_col_name_bool
      THEN
         IF l_result = 'COLUMN_NAME'
         THEN
            l_result := TRIM(i_line);
            l_result := substr(l_result
                              ,instr(l_result, '"', 1, 3) + 1
                              ,instr(l_result, '"', 1, 4) -
                               instr(l_result, '"', 1, 3) - 1);
         END IF;
      END IF;
      RETURN l_result;
   END fn_get_attribute;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_attribute
   (
      i_line                     IN VARCHAR2
     ,i_suppress_get_col_name_vc IN VARCHAR2 DEFAULT 'FALSE'
   ) RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN fn_get_attribute(i_line                       => i_line
                             ,i_suppress_get_col_name_bool => (CASE
                                                               i_suppress_get_col_name_vc
                                                                 WHEN
                                                                  'TRUE' THEN
                                                                  TRUE
                                                                 ELSE
                                                                  FALSE
                                                              END));
   END fn_get_attribute;

   ----------------------------------------------------------------------------

   FUNCTION fn_upper_keyword_clob
   (
      i_statement IN CLOB
     ,i_keyword   IN VARCHAR2
   ) RETURN CLOB IS
      l_u_statement CLOB := upper(i_statement);
      l_u_keyword   VARCHAR2(500) := upper(i_keyword);
      l_return      CLOB;
      l_pos         NUMBER;
   BEGIN
      l_pos    := instr(l_u_statement, l_u_keyword);
      l_return := i_statement;
      WHILE l_pos > 0
      LOOP
         IF substr(l_return, l_pos, length(l_u_keyword)) !=
            l_u_keyword
         THEN
            l_return := substr(l_return, 1, l_pos - 1) || l_u_keyword ||
                        substr(l_return, l_pos + length(l_u_keyword));
         END IF;
      
         l_pos := instr(l_u_statement || ' ', l_u_keyword, l_pos + 1);
      END LOOP;
      RETURN l_return;
   END fn_upper_keyword_clob;

   ----------------------------------------------------------------------------

   -- Cannot be used by the FORM.. because of the result cache.
   -- This is used alot during processing so we REALLY want to result cache this.
   FUNCTION fn_upper_keyword_varchar2
   (
      i_statement IN VARCHAR2
     ,i_keyword   IN VARCHAR2
   ) RETURN VARCHAR2 IS
      l_u_statement VARCHAR2(32767) := upper(i_statement);
      l_u_keyword   VARCHAR2(500) := upper(i_keyword);
      l_return      VARCHAR2(32767);
      l_pos         NUMBER;
   BEGIN
      l_pos    := instr(l_u_statement, l_u_keyword);
      l_return := i_statement;
      WHILE l_pos > 0
      LOOP
         IF substr(l_return, l_pos, length(l_u_keyword)) !=
            l_u_keyword
         THEN
            l_return := substr(l_return, 1, l_pos - 1) || l_u_keyword ||
                        substr(l_return, l_pos + length(l_u_keyword));
         END IF;
      
         l_pos := instr(l_u_statement || ' ', l_u_keyword, l_pos + 1);
      END LOOP;
      RETURN l_return;
   
   END fn_upper_keyword_varchar2;

   ----------------------------------------------------------------------------

   FUNCTION fn_is_next_line_array_start
   (
      i_document    IN VARCHAR2
     ,i_line_number IN NUMBER
   ) RETURN BOOLEAN IS
      --
      CURSOR cur_pejl
      (
         c_document    IN VARCHAR2
        ,c_line_number IN NUMBER
      ) IS
         SELECT TRIM(pejl.json_line) json_line
           FROM pre_etl_json_lines pejl
          WHERE pejl.document_name = c_document
            AND pejl.line_number > c_line_number
          ORDER BY pejl.line_number;
      cur_pejl_buf cur_pejl%ROWTYPE;
   BEGIN
      OPEN cur_pejl(c_document    => i_document
                   ,c_line_number => i_line_number);
      FETCH cur_pejl
         INTO cur_pejl_buf;
      CLOSE cur_pejl;
      --
      IF cur_pejl_buf.json_line = '['
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fn_is_next_line_array_start;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_pedc2
   (
      i_search IN VARCHAR2
     ,i_next   IN NUMBER
   ) RETURN cur_pedc2%ROWTYPE IS
      cur_pedc2_buf cur_pedc2%ROWTYPE;
      l_search      VARCHAR2(500) := REPLACE(i_search, '_', '/_');
   BEGIN
      OPEN cur_pedc2(c_search => l_search, c_next => i_next);
      FETCH cur_pedc2
         INTO cur_pedc2_buf;
      CLOSE cur_pedc2;
      --
      RETURN cur_pedc2_buf;
   END fn_get_pedc2;

   ----------------------------------------------------------------------------

   FUNCTION fn_code_state
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN VARCHAR2 IS
   
      CURSOR cur_pemh
      (
         c_migration_group IN VARCHAR2
        ,c_migration_name  IN VARCHAR2
      ) IS
         SELECT pemh.statement_has_errors_ynu
           FROM pre_etl_migration_header pemh
          WHERE pemh.migration_group = c_migration_group
            AND pemh.migration_name = c_migration_name;
      cur_pemh_buf cur_pemh%ROWTYPE;
   BEGIN
      OPEN cur_pemh(c_migration_group => i_migration_group
                   ,c_migration_name  => i_migration_name);
      FETCH cur_pemh
         INTO cur_pemh_buf;
      CLOSE cur_pemh;
      --
      IF nvl(cur_pemh_buf.statement_has_errors_ynu, 'U') = 'U'
      THEN
         RETURN 'UNKNOWN';
      ELSIF cur_pemh_buf.statement_has_errors_ynu = 'Y'
      THEN
         RETURN 'ERROR';
      ELSE
         RETURN 'CODE';
      END IF;
   END fn_code_state;

   ----------------------------------------------------------------------------

   FUNCTION fn_def_change_bool
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
     ,i_context         IN VARCHAR2
   ) RETURN BOOLEAN IS
      CURSOR cur_pemh
      (
         c_migration_group IN VARCHAR2
        ,c_migration_name  IN VARCHAR2
      ) IS
         SELECT pemh.*
           FROM pre_etl_migration_header pemh
          WHERE pemh.migration_group = c_migration_group
            AND pemh.migration_name = c_migration_name;
      cur_pemh_buf cur_pemh%ROWTYPE;
      --
      l_dummy      pkg_pre_etl_tools.t_vc_tab;
      l_dummy_bool BOOLEAN;
      l_hash_1     RAW(16);
      l_hash_2     RAW(16);
   BEGIN
      -- Check to see if the hash of the clob as it is now differs from what it would
      -- be if we rebuilt now.
      OPEN cur_pemh(c_migration_group => i_migration_group
                   ,c_migration_name  => i_migration_name);
      FETCH cur_pemh
         INTO cur_pemh_buf;
      CLOSE cur_pemh;
      --
      IF cur_pemh_buf.executable_statement IS NOT NULL
      THEN
         l_hash_1 := fn_get_hash_for_clob(i_clob => cur_pemh_buf.executable_statement);
         pr_create_executable_statement(i_migration_group          => i_migration_group
                                       ,i_migration_name           => i_migration_name
                                       ,i_compile_test_bool        => FALSE
                                       ,i_context                  => i_context
                                       ,o_tab_executable_statement => l_dummy
                                       ,o_hash                     => l_hash_2
                                       ,o_tab_errors               => l_dummy
                                       ,o_errors_bool              => l_dummy_bool);
         IF l_hash_1 != l_hash_2
         THEN
            RETURN TRUE;
         ELSE
            RETURN FALSE;
         END IF;
      ELSE
         RETURN FALSE;
      END IF;
   
   END fn_def_change_bool;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_executable_statement
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN t_vc_tab IS
      l_return CLOB;
   BEGIN
      SELECT pemh.executable_statement
        INTO l_return
        FROM pre_etl_migration_header pemh
       WHERE pemh.migration_group = i_migration_group
         AND pemh.migration_name = i_migration_name;
      --
      RETURN fn_cut_clob_to_tab(i_clob => l_return);
   END fn_get_executable_statement;

   ----------------------------------------------------------------------------

   FUNCTION fn_pretty_json(i_json_text IN VARCHAR2) RETURN VARCHAR2 IS
      l_return VARCHAR2(32767);
   BEGIN
      SELECT json_query(i_json_text
                       ,'$' RETURNING VARCHAR2(32767) pretty)
        INTO l_return
        FROM dual;
      --
      RETURN ltrim(rtrim(l_return, fn_lf), fn_lf);
   END fn_pretty_json;

   ----------------------------------------------------------------------------

   FUNCTION fn_flattened_json(i_json_text IN VARCHAR2) RETURN VARCHAR2 IS
      l_return VARCHAR2(32767);
   BEGIN
      SELECT json_query(i_json_text
                       ,'$' RETURNING VARCHAR2(32767) ascii)
        INTO l_return
        FROM dual;
      --
      RETURN rtrim(l_return, fn_lf);
   END fn_flattened_json;

   ----------------------------------------------------------------------------

   FUNCTION fn_find_and_swap
   (
      i_find_swap_string IN VARCHAR2
     ,i_mig_group        IN VARCHAR2 DEFAULT NULL
   ) RETURN VARCHAR2 IS
      l_return_string   VARCHAR2(32767) := i_find_swap_string;
      l_previous_string VARCHAR2(32767);
      l_count           PLS_INTEGER := 0;
   BEGIN
      IF i_find_swap_string IS NOT NULL
         AND i_mig_group IS NOT NULL
      THEN
         WHILE TRUE
         LOOP
            l_count := l_count + 1;
            -- infinite loop check.
            IF l_count > 100
            THEN
               raise_application_error(-20000
                                      ,'pkg_pre_etl_tools : fn_find_and_swap : Probable infinite loop.');
            END IF;
            --
            l_previous_string := l_return_string;
            IF g_cache_find_swap.COUNT > 0
            THEN
               FOR i IN g_cache_find_swap.FIRST .. g_cache_find_swap.LAST
               LOOP
                  IF g_cache_find_swap(i)
                   .mig_group = i_mig_group
                      OR g_cache_find_swap(i).mig_group IS NULL
                  THEN
                     l_return_string := REPLACE(l_return_string
                                               ,g_cache_find_swap(i)
                                                .find_value
                                               ,g_cache_find_swap(i)
                                                .swap_value);
                  END IF;
               END LOOP;
            END IF;
            --
            IF l_return_string = l_previous_string
            THEN
               EXIT;
            END IF;
         END LOOP;
      END IF;
      --
      RETURN l_return_string;
   EXCEPTION
      WHEN OTHERS THEN
         migration_run_framework.pr_log(i_log_type          => migration_run_framework.fn_info
                                       ,i_log_entry         => 'String 1 vs String 2 : About to fail. (prev)'
                                       ,i_log_extended_info => l_previous_string);
         migration_run_framework.pr_log(i_log_type          => migration_run_framework.fn_info
                                       ,i_log_entry         => 'String 1 vs String 2 : About to fail. (return)'
                                       ,i_log_extended_info => l_return_string);
         RAISE;
   END fn_find_and_swap;

   ----------------------------------------------------------------------------

   FUNCTION fn_intra_clear(i_string IN VARCHAR2) RETURN VARCHAR2 IS
      l_return_string CLOB := i_string;
      l_idx           VARCHAR2(500);
   BEGIN
      -- This is used to remove pieces of JSON that we don't want cluttering 
      -- up our assembled JSON (empty attributes etc).
      IF g_json_intra_clear.COUNT > 0
      THEN
         l_idx := g_json_intra_clear.FIRST;
         WHILE l_idx IS NOT NULL
         LOOP
            l_return_string := REPLACE(l_return_string
                                      ,l_idx || ','
                                      ,NULL);
            l_return_string := REPLACE(l_return_string, l_idx, NULL);
            l_idx           := g_json_intra_clear.next(l_idx);
         END LOOP;
      END IF;
      --
      RETURN l_return_string;
   END fn_intra_clear;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_xml_to_json_stylesheet RETURN VARCHAR2 AS
   
   BEGIN
      RETURN q'[<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<!--
  Copyright (c) 2006,2008 Doeke Zanstra
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer. Redistributions in binary
  form must reproduce the above copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other materials provided with
  the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
-->

  <xsl:output indent="no" omit-xml-declaration="yes" method="text" encoding="UTF-8" media-type="text/x-json"/>
        <xsl:strip-space elements="*"/>
  <!--contant-->
  <xsl:variable name="d">0123456789</xsl:variable>

  <!-- ignore document text -->
  <xsl:template match="text()[preceding-sibling::node() or following-sibling::node()]"/>

  <!-- string -->
  <xsl:template match="text()">
    <xsl:call-template name="escape-string">
      <xsl:with-param name="s" select="."/>
    </xsl:call-template>
  </xsl:template>

  <!-- Main template for escaping strings; used by above template and for object-properties
       Responsibilities: placed quotes around string, and chain up to next filter, escape-bs-string -->
  <xsl:template name="escape-string">
    <xsl:param name="s"/>
    <xsl:text>"</xsl:text>
    <xsl:call-template name="escape-bs-string">
      <xsl:with-param name="s" select="$s"/>
    </xsl:call-template>
    <xsl:text>"</xsl:text>
  </xsl:template>

  <!-- Escape the backslash (\) before everything else. -->
  <xsl:template name="escape-bs-string">
    <xsl:param name="s"/>
    <xsl:choose>
      <xsl:when test="contains($s,'\')">
        <xsl:call-template name="escape-quot-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'\'),'\\')"/>
        </xsl:call-template>
        <xsl:call-template name="escape-bs-string">
          <xsl:with-param name="s" select="substring-after($s,'\')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="escape-quot-string">
          <xsl:with-param name="s" select="$s"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Escape the double quote ("). -->
  <xsl:template name="escape-quot-string">
    <xsl:param name="s"/>
    <xsl:choose>
      <xsl:when test="contains($s,'&quot;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&quot;'),'\&quot;')"/>
        </xsl:call-template>
        <xsl:call-template name="escape-quot-string">
          <xsl:with-param name="s" select="substring-after($s,'&quot;')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="$s"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Replace tab, line feed and/or carriage return by its matching escape code. Can't escape backslash
       or double quote here, because they don't replace characters (&#x0; becomes \t), but they prefix
       characters (\ becomes \\). Besides, backslash should be seperate anyway, because it should be
       processed first. This function can't do that. -->
  <xsl:template name="encode-string">
    <xsl:param name="s"/>
    <xsl:choose>
      <!-- tab -->
      <xsl:when test="contains($s,'&#x9;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&#x9;'),'\t',substring-after($s,'&#x9;'))"/>
        </xsl:call-template>
      </xsl:when>
      <!-- line feed -->
      <xsl:when test="contains($s,'&#xA;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&#xA;'),'\n',substring-after($s,'&#xA;'))"/>
        </xsl:call-template>
      </xsl:when>
      <!-- carriage return -->
      <xsl:when test="contains($s,'&#xD;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&#xD;'),'\r',substring-after($s,'&#xD;'))"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise><xsl:value-of select="$s"/></xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- number (no support for javascript mantissa) -->
  <xsl:template match="text()[not(string(number())='NaN' or
                      (starts-with(.,'0' ) and . != '0' and
not(starts-with(.,'0.' ))) or
                      (starts-with(.,'-0' ) and . != '-0' and
not(starts-with(.,'-0.' )))
                      )]">
    <!-- Tag Names that start with QTD_ (for quoted) surround the value with quotes ALWAYS! 
         Even if they are thought to be numbers...
    -->
    <xsl:variable name="tagName" select="name(..)"/>                      
    <xsl:choose>                      
      <xsl:when test="starts-with(string($tagName),'QTD_')">
          <xsl:value-of select="concat('&quot;',.,'&quot;')"/>
      </xsl:when>
      <xsl:otherwise><xsl:value-of select="."/></xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- boolean, case-insensitive -->
  <xsl:template match="text()[translate(.,'TRUE','true')='true']">true</xsl:template>
  <xsl:template match="text()[translate(.,'FALSE','false')='false']">false</xsl:template>

  <!-- object -->
  <xsl:template match="*" name="base">
    <xsl:if test="not(preceding-sibling::*)">{</xsl:if>
    <xsl:call-template name="escape-string">
      <xsl:with-param name="s" select="name()"/>
    </xsl:call-template>
    <xsl:text>:</xsl:text>
    <!-- check type of node -->
    <xsl:choose>
      <!-- null nodes -->
      <xsl:when test="count(child::node())=0">null</xsl:when>
      <!-- other nodes -->
      <xsl:otherwise>
        <xsl:apply-templates select="child::node()"/>
      </xsl:otherwise>
    </xsl:choose>
    <!-- end of type check -->
    <xsl:if test="following-sibling::*">,</xsl:if>
    <xsl:if test="not(following-sibling::*)">}</xsl:if>
  </xsl:template>

  <!-- array -->
  <xsl:template match="*[count(../*[name(../*)=name(.)])=count(../*) and count(../*)&gt;1]">
    <xsl:if test="not(preceding-sibling::*)">[</xsl:if>
    <xsl:choose>
      <xsl:when test="not(child::node())">
        <xsl:text>null</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="child::node()"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="following-sibling::*">,</xsl:if>
    <xsl:if test="not(following-sibling::*)">]</xsl:if>
  </xsl:template>

  <!-- convert root element to an anonymous container -->
  <xsl:template match="/">
    <xsl:apply-templates select="node()"/>
  </xsl:template>

</xsl:stylesheet>]';
   
   END fn_get_xml_to_json_stylesheet;

   ----------------------------------------------------------------------------

   FUNCTION fn_ref_cursor_to_json
   (
      p_ref_cursor IN SYS_REFCURSOR
     ,p_max_rows   IN NUMBER := NULL
     ,p_skip_rows  IN NUMBER := NULL
   ) RETURN VARCHAR2 AS
      l_ctx         dbms_xmlgen.ctxhandle;
      l_num_rows    PLS_INTEGER;
      l_xml         xmltype;
      l_returnvalue VARCHAR2(32767);
   BEGIN
   
      l_ctx := dbms_xmlgen.newcontext(p_ref_cursor);
   
      dbms_xmlgen.setnullhandling(l_ctx, dbms_xmlgen.empty_tag);
   
      -- for pagination
      IF p_max_rows IS NOT NULL
      THEN
         dbms_xmlgen.setmaxrows(l_ctx, p_max_rows);
      END IF;
   
      IF p_skip_rows IS NOT NULL
      THEN
         dbms_xmlgen.setskiprows(l_ctx, p_skip_rows);
      END IF;
   
      -- get the XML content
      l_xml := dbms_xmlgen.getxmltype(l_ctx, dbms_xmlgen.none);
   
      l_num_rows := dbms_xmlgen.getnumrowsprocessed(l_ctx);
   
      dbms_xmlgen.closecontext(l_ctx);
   
      CLOSE p_ref_cursor;
   
      IF l_num_rows > 0
      THEN
         -- perform the XSL transformation
         -- The original code did this (see below comments), but I had to 
         -- change it to a select from dual to handle the ampersands.
         -- l_json := l_xml.transform(xmltype(fn_get_xml_to_json_stylesheet));
         -- l_returnvalue := l_json.getclobval();
         SELECT xmltransform(l_xml, xmltype(fn_get_xml_to_json_stylesheet))
                .getclobval()
           INTO l_returnvalue
           FROM dual;
      ELSE
         l_returnvalue := g_const_json_null_object;
      END IF;
   
      l_returnvalue := dbms_xmlgen.convert(l_returnvalue
                                          ,dbms_xmlgen.entity_decode);
   
      RETURN l_returnvalue;
   
   EXCEPTION
      WHEN scanner_exception THEN
         dbms_output.put('Scanner problem with the following input: ');
         pr_dbms_output(l_returnvalue);
         RAISE;
      WHEN parser_exception THEN
         dbms_output.put('Parser problem with the following input: ');
         pr_dbms_output(l_returnvalue);
         RAISE;
      WHEN OTHERS THEN
         RAISE;
   END fn_ref_cursor_to_json;

   ----------------------------------------------------------------------------
   FUNCTION fn_sql_to_vanilla_array
   (
      i_sql       IN VARCHAR2
     ,i_mig_group IN VARCHAR2
   ) RETURN VARCHAR2 result_cache IS
   
      l_rc           SYS_REFCURSOR;
      l_value        VARCHAR2(32767);
      l_return_value VARCHAR2(32767) := '[';
      l_sql          VARCHAR2(32767) := REPLACE(REPLACE(i_sql
                                                       ,chr(10)
                                                       ,' ')
                                               ,chr(13)
                                               ,' ');
      l_quoted       PLS_INTEGER := 0;
      l_loop_count   PLS_INTEGER := 0;
      FUNCTION fn_numeric(i_val IN VARCHAR2) RETURN BOOLEAN IS
         l_num NUMBER;
      BEGIN
         l_num := to_number(i_val);
         RETURN TRUE;
      EXCEPTION
         WHEN OTHERS THEN
            RETURN FALSE;
      END fn_numeric;
   BEGIN
      WHILE TRUE
      LOOP
         IF l_loop_count = 1
         THEN
            l_return_value := '[';
         ELSIF l_loop_count > 1
         THEN
            EXIT;
         END IF;
         --
         l_loop_count := l_loop_count + 1;
         --    
         IF instr(upper(l_sql), ' QTD_') > 0
         THEN
            l_quoted := 1;
         END IF;
         --
         OPEN l_rc FOR l_sql;
         WHILE TRUE
         LOOP
            FETCH l_rc
               INTO l_value;
            --
            IF l_quoted = 0
               AND NOT fn_numeric(i_val => l_value)
            THEN
               l_quoted := 1;
               CLOSE l_rc;
               EXIT;
            END IF;
            --
            IF l_rc%NOTFOUND
            THEN
               CLOSE l_rc;
               EXIT;
            END IF;
            --
            l_return_value := l_return_value || (CASE l_quoted
                                 WHEN 1 THEN
                                  '"'
                                 ELSE
                                  NULL
                              END) || l_value || (CASE l_quoted
                                 WHEN 1 THEN
                                  '"'
                                 ELSE
                                  NULL
                              END) || ',';
         END LOOP;
         l_return_value := rtrim(l_return_value, ',') || ']';
      END LOOP;
   
      RETURN fn_find_and_swap(i_find_swap_string => l_return_value
                             ,i_mig_group        => i_mig_group);
   EXCEPTION
      WHEN OTHERS THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools.fn_sql_to_vanilla_array : Cannot execute array SQL - check there is ONLY ONE value returned.');
   END fn_sql_to_vanilla_array;

   ----------------------------------------------------------------------------

   FUNCTION fn_sql_to_json
   (
      i_sql          IN VARCHAR2
     ,i_max_rows     IN NUMBER := NULL
     ,i_skip_rows    IN NUMBER := NULL
     ,i_mig_group    IN VARCHAR2
     ,i_find_swap_yn IN VARCHAR2 DEFAULT 'Y'
   ) RETURN VARCHAR2 AS
      v_cur SYS_REFCURSOR;
   BEGIN
      OPEN v_cur FOR i_sql;
      IF i_find_swap_yn = 'Y'
      THEN
         RETURN fn_find_and_swap(i_find_swap_string => fn_ref_cursor_to_json(v_cur
                                                                            ,i_max_rows
                                                                            ,i_skip_rows)
                                ,i_mig_group        => i_mig_group);
      ELSE
         RETURN fn_ref_cursor_to_json(v_cur, i_max_rows, i_skip_rows);
      END IF;
   END fn_sql_to_json;

   ----------------------------------------------------------------------------
   -- See the original version after this function.
   -- This is a string verification rather than JSON handling.

   FUNCTION fn_sql_to_json_array
   (
      i_sql          IN VARCHAR2
     ,i_mig_group    IN VARCHAR2
     ,i_find_swap_yn IN VARCHAR2 DEFAULT 'Y'
   ) RETURN VARCHAR2 IS
      l_json        VARCHAR2(32727);
      l_return_json VARCHAR2(32727);
      l_sql         VARCHAR2(32727);
      --
      -- Trim the SINGLE last occurrance (no more).
      FUNCTION fn_trim_last
      (
         i_clob  IN CLOB
        ,i_chars IN VARCHAR2
      ) RETURN CLOB IS
         l_length        NUMBER := length(i_clob);
         l_chars_removed NUMBER;
         l_return        CLOB;
      BEGIN
         l_return        := rtrim(i_clob, i_chars);
         l_chars_removed := l_length - length(l_return);
         IF l_chars_removed > length(i_chars)
         THEN
            FOR i IN 1 .. (l_chars_removed / length(i_chars)) - 1
            LOOP
               l_return := l_return || i_chars;
            END LOOP;
         END IF;
         -- 
         RETURN l_return;
      END fn_trim_last;
   BEGIN
      l_sql := fn_contextualize(i_subject => i_sql
                               ,i_context => g_run_context);
      -- We need to capture the SQL in case the make_json call throws an exception and we need to see what happened during the call.
      g_sql_array_debug(g_sql_array_debug.COUNT + 1) := l_sql;
      --
      l_json := fn_flattened_json(fn_sql_to_json(i_sql          => l_sql
                                                ,i_mig_group    => i_mig_group
                                                ,i_find_swap_yn => i_find_swap_yn));
      --
      IF l_json = '{}'
      THEN
         l_return_json := '[]';
      ELSIF l_json LIKE '{"ROWSET":{"ROW":%'
      THEN
         -- 17 chars for {"ROWSET":{"ROW": trimmed off
         -- last 2 closing } trimmed off (to balance the above)
         -- then surrounded with []
         l_return_json := substr(l_json, 18);
         l_return_json := substr(l_return_json
                                ,1
                                ,length(l_return_json) - 2);
         l_return_json := '[' || l_return_json || ']';
      ELSE
         l_return_json := fn_trim_last(substr(l_json
                                             ,instr(l_json, '[', 1, 1))
                                      ,'}');
      END IF;
      RETURN TRIM(l_return_json);
   
   END fn_sql_to_json_array;

   ----------------------------------------------------------------------------
   FUNCTION fn_check_for_ob
   (
      i_string       IN VARCHAR2
     ,i_after_string IN VARCHAR2
   ) RETURN NUMBER IS
      l_pos NUMBER;
   BEGIN
      -- Check for first open bracket.  If found return position if any other non space char found then fail.
      l_pos := instr(i_string, i_after_string);
      l_pos := l_pos + length(i_after_string);
      WHILE TRUE
      LOOP
         IF l_pos > length(i_string)
         THEN
            raise_application_error(-20000, 'No open bracket found.');
         END IF;
         --
         IF substr(i_string, l_pos, 1) = '('
         THEN
            RETURN l_pos;
         END IF;
         --
         IF substr(i_string, l_pos, 1) NOT IN (' ', fn_lf, chr(13))
         THEN
            raise_application_error(-20000
                                   ,'Expected open bracket missing.');
         END IF;
         --
         l_pos := l_pos + 1;
      END LOOP;
   END fn_check_for_ob;

   ----------------------------------------------------------------------------

   FUNCTION fn_set_json_handler
   (
      i_value             IN VARCHAR2
     ,i_mr_group          IN VARCHAR2
     ,i_mig_group         IN VARCHAR2
     ,i_introspect_step   IN VARCHAR2
     ,i_use_driver_bool   IN BOOLEAN DEFAULT FALSE
     ,i_smart_cache_attrs IN VARCHAR2
   ) RETURN VARCHAR2 IS
      l_value   VARCHAR2(32767) := i_value;
      l_return  VARCHAR2(32767);
      l_replace VARCHAR2(250) := g_const_json_handler || '(' ||
                                 g_const_json_handler_p0 ||
                                 '=> :batch,' ||
                                 g_const_json_handler_p1 || '=>';
      l_pos     NUMBER;
      l_ob      NUMBER := 0;
      --
      c_const_spacing        CONSTANT VARCHAR2(16) := chr(10) ||
                                                      rpad(' '
                                                          ,5
                                                          ,' ');
      c_const_utility_fields CONSTANT VARCHAR2(2000) := c_const_spacing || ',' ||
                                                        g_const_json_handler_p7 ||
                                                        '=> mig_driver_utility_field_1' ||
                                                        c_const_spacing || ',' ||
                                                        g_const_json_handler_p8 ||
                                                        '=> mig_driver_utility_field_2' ||
                                                        c_const_spacing || ',' ||
                                                        g_const_json_handler_p9 ||
                                                        '=> mig_driver_utility_field_3' ||
                                                        c_const_spacing || ',' ||
                                                        g_const_json_handler_p10 ||
                                                        '=> mig_driver_utility_field_4' ||
                                                        c_const_spacing || ',' ||
                                                        g_const_json_handler_p11 ||
                                                        '=> mig_driver_utility_field_5';
   BEGIN
      l_return := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_value
                                                                     ,i_keyword   => g_tool_const_json)
                         ,g_tool_const_json
                         ,l_replace);
      l_pos    := fn_check_for_ob(i_string       => i_value
                                 ,i_after_string => g_tool_const_json) +
                  (length(l_replace) - length(g_tool_const_json));
      WHILE TRUE
      LOOP
         IF l_pos > length(l_return)
         THEN
            raise_application_error(-20000, 'No open bracket found.');
         END IF;
         CASE substr(l_return, l_pos, 1)
            WHEN '(' THEN
               l_ob := l_ob + 1;
            WHEN ')' THEN
               l_ob := l_ob - 1;
            ELSE
               NULL;
         END CASE;
         --
         EXIT WHEN l_ob = 0;
         --
         l_pos := l_pos + 1;
      END LOOP;
      --
      l_return := substr(l_return, 1, l_pos) || ',' ||
                  g_const_json_handler_p2 || '=> nv_pair_tab' ||
                  c_const_spacing || ',' || g_const_json_handler_p3 ||
                  '=> ''' || g_tool_const_src || '''' || c_const_spacing || ',' ||
                  g_const_json_handler_p4 || '=> ''' || i_mr_group || '''' ||
                  c_const_spacing || ',' || g_const_json_handler_p5 ||
                  '=> ''' || i_mig_group || '''' || c_const_spacing || ',' ||
                  g_const_json_handler_p6 || '=> ' || fn_mck ||
                  (CASE i_use_driver_bool
                      WHEN TRUE THEN
                       c_const_utility_fields
                      ELSE
                       NULL
                   END) || c_const_spacing || ',' ||
                  g_const_json_handler_p12 || '=> ' || chr(39) ||
                  i_introspect_step || chr(39) ||
                  (CASE
                      WHEN i_smart_cache_attrs IS NOT NULL THEN
                       c_const_spacing || ',' || g_const_json_handler_p13 ||
                       '=> ' || fn_sck || c_const_spacing || ',' ||
                       g_const_json_handler_p14 || '=> ' || chr(39) ||
                       i_smart_cache_attrs || chr(39)
                      ELSE
                       NULL
                   END) || ')' || substr(l_return, l_pos + 1);
      --
      RETURN l_return;
   END fn_set_json_handler;

   ----------------------------------------------------------------------------

   FUNCTION fn_nv_pairs
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
     ,i_mr_group        IN VARCHAR2
   ) RETURN CLOB IS
      l_return  CLOB := ' ';
      l_count   NUMBER := 0;
      l_initial VARCHAR2(500);
   BEGIN
      FOR i_buf IN (SELECT pems.table_name
                      FROM pre_etl_migration_src pems
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'N')
      LOOP
         l_count := l_count + 1;
         --
         IF l_count = 1
         THEN
            dbms_lob.append(l_return
                           ,'CAST(MULTISET( SELECT * FROM ( ' ||
                            fn_lf);
            l_initial := '               ';
         ELSE
            dbms_lob.append(l_return
                           ,' ' || fn_lf || '               UNION ' ||
                            fn_lf);
            l_initial := '               ';
         END IF;
         dbms_lob.append(l_return
                        ,l_initial || 'SELECT /*Action Fingerprint:' ||
                         fn_get_action_comments_hash(i_using_src_table_name => i_buf.table_name
                                                    ,i_mr_group             => i_mr_group) || '*/' ||
                         chr(39) || i_buf.table_name || '.' ||
                         chr(39) || '||column_name AS column_name ' ||
                         fn_lf ||
                         '                            ,column_value' ||
                         fn_lf || l_initial || '  FROM (SELECT ');
      
         l_initial := NULL;
      
         FOR i2_buf IN (SELECT (CASE pedc.column_type
                                  WHEN 'TIMESTAMP' THEN
                                   'chr(39)||to_char('
                                  WHEN 'TIMESTAMP(6)' THEN
                                   'chr(39)||to_char('
                                  WHEN 'DATE' THEN
                                   'chr(39)||to_char('
                                  WHEN 'SMALLINT' THEN
                                   'to_char('
                                  WHEN 'DECIMAL' THEN
                                   'to_char('
                                  WHEN 'NUMBER' THEN
                                   'to_char('
                                  WHEN 'INTEGER' THEN
                                   'to_char('
                                  WHEN 'TIME' THEN
                                   'chr(39)||to_char('
                                  ELSE
                                   'chr(39)||REPLACE('
                               END) || pedc.table_name || '.' ||
                               pedc.column_name ||
                               (CASE pedc.column_type
                                  WHEN 'TIMESTAMP' THEN
                                   ',''DD-MON-YYYY HH24.MI.SS.FF6'')||chr(39) ' ||
                                   pedc.column_name
                                  WHEN 'TIMESTAMP(6)' THEN
                                   ',''DD-MON-YYYY HH24.MI.SS.FF6'')||chr(39) ' ||
                                   pedc.column_name
                                  WHEN 'DATE' THEN
                                   ', ''DD-MON-YYYY HH24.MI.SS'')||chr(39) ' ||
                                   pedc.column_name
                                  WHEN 'SMALLINT' THEN
                                   ') ' || pedc.column_name
                                  WHEN 'DECIMAL' THEN
                                   ') ' || pedc.column_name
                                  WHEN 'NUMBER' THEN
                                   ') ' || pedc.column_name
                                  WHEN 'INTEGER' THEN
                                   ') ' || pedc.column_name
                                  WHEN 'TIME' THEN
                                   ')||chr(39) ' || pedc.column_name
                                  ELSE
                                   ',chr(39),chr(39)||chr(39))||chr(39) ' ||
                                   pedc.column_name
                               END) col
                              ,row_number() over(ORDER BY column_pos) AS rn_cnt
                          FROM pre_etl_db2_columns pedc
                         WHERE pedc.table_name = i_buf.table_name
                           AND pedc.column_pos >= 0
                           AND pkg_pre_etl_tools.fn_is_src_col_is_mapped_vc(i_table_name  => pedc.table_name
                                                                           ,i_column_name => pedc.column_name
                                                                           ,i_mr_group    => i_mr_group) =
                               'TRUE'
                         ORDER BY pedc.column_pos)
         LOOP
            IF MOD(i2_buf.rn_cnt, 15) = 0
            THEN
               dbms_lob.append(l_return, chr(10));
            END IF;
            dbms_lob.append(l_return, l_initial || i2_buf.col);
            l_initial := ' , ' || fn_lf || '                       ';
         END LOOP;
         --
         dbms_lob.append(l_return
                        ,fn_lf ||
                         '                                  ' ||
                         ' FROM dual) ' || fn_lf ||
                         '                           ' ||
                         ' unpivot include NULLS(column_value FOR column_name IN(');
         --
         l_initial := NULL;
         FOR i2_buf IN (SELECT pedc.column_name col
                          FROM pre_etl_db2_columns pedc
                         WHERE pedc.table_name = i_buf.table_name
                           AND pedc.column_pos >= 0
                           AND fn_is_src_col_is_mapped_vc(i_table_name  => pedc.table_name
                                                         ,i_column_name => pedc.column_name
                                                         ,i_mr_group    => i_mr_group) =
                               'TRUE'
                         ORDER BY pedc.column_pos)
         LOOP
            dbms_lob.append(l_return, l_initial || i2_buf.col);
            l_initial := ', ';
         END LOOP;
         dbms_lob.append(l_return, '))');
      END LOOP;
      dbms_lob.append(l_return, ')');
      --
      -- NOTE : This order by descending is important (don't change this) as we do some replacing later, 
      --        if we do not use the order by, then columns that have partially similar starting names will 
      --        be incorrectly replaced.
      dbms_lob.append(l_return
                     ,'order by length (column_name) DESC ) ' ||
                      fn_lf || '            AS' || fn_lf ||
                      '            t_nv_pair_tab) nv_pair_tab');
      --
      RETURN l_return;
   END fn_nv_pairs;

   ----------------------------------------------------------------------------

   FUNCTION fn_is_src_col_is_mapped
   (
      i_table_name  IN VARCHAR2
     ,i_column_name IN VARCHAR2
     ,i_mr_group    IN VARCHAR2
   ) RETURN BOOLEAN IS
      CURSOR cur_is_mapped
      (
         c_table_name  IN VARCHAR2
        ,c_column_name IN VARCHAR2
        ,c_mr_group    IN VARCHAR2
      ) IS
         SELECT NULL
           FROM pre_etl_mapped             pem
               ,pre_etl_related_json_lines perjl
          WHERE perjl.relationship_group_id =
                pem.relationship_group_id
            AND perjl.mr_group = pem.mr_group
            AND pem.table_name = c_table_name
            AND pem.column_name = c_column_name
            AND pem.mr_group = c_mr_group
            AND rownum = 1;
      cur_is_mapped_buf cur_is_mapped%ROWTYPE;
      --
      l_return BOOLEAN;
   BEGIN
      OPEN cur_is_mapped(c_table_name  => upper(i_table_name)
                        ,c_column_name => upper(i_column_name)
                        ,c_mr_group    => i_mr_group);
      FETCH cur_is_mapped
         INTO cur_is_mapped_buf;
      l_return := cur_is_mapped%FOUND;
      CLOSE cur_is_mapped;
      --
      RETURN l_return;
   END fn_is_src_col_is_mapped;

   ----------------------------------------------------------------------------

   FUNCTION fn_is_src_col_is_mapped_vc
   (
      i_table_name  IN VARCHAR2
     ,i_column_name IN VARCHAR2
     ,i_mr_group    IN VARCHAR2
   ) RETURN VARCHAR2 IS
   BEGIN
      IF fn_is_src_col_is_mapped(i_table_name  => i_table_name
                                ,i_column_name => i_column_name
                                ,i_mr_group    => i_mr_group)
      THEN
         RETURN 'TRUE';
      ELSE
         RETURN 'FALSE';
      END IF;
   END fn_is_src_col_is_mapped_vc;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_command_comments
   (
      i_relationship_group_id IN NUMBER
     ,i_mr_group              IN VARCHAR2
   ) RETURN t_rec_pec_fla result_cache IS
      --
      l_buf t_rec_pec_fla;
      --
      CURSOR cur_pec
      (
         c_relationship_group_id IN NUMBER
        ,c_mr_group              IN VARCHAR2
      ) IS
         SELECT substr(function_value, 2) function_value
               ,lookup_value
               ,array_value
           FROM (SELECT pec.mr_group
                       ,pec.relationship_group_id
                       ,decode(pec.comment_type
                              ,'V'
                              ,'A'
                              ,pec.comment_type) AS comment_type
                       ,CAST(pec.comments AS VARCHAR2(32000)) AS comments
                   FROM pre_etl_comments pec
                  WHERE pec.relationship_group_id =
                        c_relationship_group_id
                    AND pec.mr_group = c_mr_group
                    AND pec.comment_type IN ('F', 'L', 'A', 'V')
                    AND decode(decode(pec.comment_type
                                     ,'V'
                                     ,'A'
                                     ,pec.comment_type)
                              ,'F'
                              ,decode(substr(CAST(pec.comments AS
                                                  VARCHAR2(32000))
                                            ,1
                                            ,1)
                                     ,'='
                                     ,1
                                     ,0)
                              ,'L'
                              ,decode(upper(substr(CAST(pec.comments AS
                                                        VARCHAR2(32000))
                                                  ,1
                                                  ,6))
                                     ,'SELECT'
                                     ,1
                                     ,decode(upper(substr(CAST(pec.comments AS
                                                               VARCHAR2(32000))
                                                         ,1
                                                         ,4))
                                            ,'WITH'
                                            ,1
                                            ,0))
                              ,'A'
                              ,decode(upper(substr(CAST(pec.comments AS
                                                        VARCHAR2(32000))
                                                  ,1
                                                  ,6))
                                     ,'SELECT'
                                     ,1
                                     ,decode(upper(substr(CAST(pec.comments AS
                                                               VARCHAR2(32000))
                                                         ,1
                                                         ,4))
                                            ,'WITH'
                                            ,1
                                            ,0))
                              ,0) = 1)
         pivot(MAX(comments)
            FOR comment_type IN('F' AS function_value
                               ,'L' AS lookup_value
                               ,'A' AS array_value));
   BEGIN
      OPEN cur_pec(c_relationship_group_id => i_relationship_group_id
                  ,c_mr_group              => i_mr_group);
      FETCH cur_pec
         INTO l_buf;
      CLOSE cur_pec;
      --
      RETURN l_buf;
   END fn_get_command_comments;

   ----------------------------------------------------------------------------

   FUNCTION fn_exists_in_string
   (
      i_string         IN VARCHAR2
     ,i_check_for_this IN VARCHAR2
   ) RETURN BOOLEAN IS
   BEGIN
      IF instr(upper(i_string), i_check_for_this) > 0
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END fn_exists_in_string;

   ----------------------------------------------------------------------------

   FUNCTION fn_process_pec_buf
   (
      i_relationship_group_id IN NUMBER
     ,i_mr_group              IN VARCHAR2
     ,i_function_value        IN VARCHAR2
     ,i_lookup_value          IN VARCHAR2
     ,i_array_value           IN VARCHAR2
   ) RETURN VARCHAR2 result_cache IS
      l_precedent VARCHAR2(30);
      l_return    VARCHAR2(32767) := NULL;
   BEGIN
      IF i_function_value IS NULL
         AND i_lookup_value IS NULL
         AND i_array_value IS NULL
      THEN
         -- If there is no special handling then we say use the mapping value (if there is one) 
         -- If we later find there is no mapping value then it will be 'NULL' in the select from dual.
         l_return := g_tool_const_mapped;
      ELSE
      
         -- If the function refers to the lookup, then the function takes precedent.
         -- If the lookup refers to the function then the lookup takes precedent.
         -- If both the lookup and the function refer to each other then throw : ex_raise_nested_lk_fn
         l_precedent := NULL;
      
         IF fn_exists_in_string(i_string         => i_function_value
                               ,i_check_for_this => g_tool_const_lookup)
         THEN
            --
            l_precedent := 'FUNCTION';
            --
         END IF;
         --
         --
         IF fn_exists_in_string(i_string         => i_lookup_value
                               ,i_check_for_this => g_tool_const_function)
         THEN
            IF l_precedent IS NOT NULL
            THEN
               ex_raise_nested_lk_fn(i_error_text => 'Relationship Group :' ||
                                                     i_relationship_group_id ||
                                                     ' : ' ||
                                                     i_mr_group);
            ELSE
               --
               l_precedent := 'LOOKUP';
               --
            END IF;
         END IF;
         --
         IF nvl(l_precedent, '?') = 'LOOKUP'
         THEN
            l_return := '(' ||
                        REPLACE(i_lookup_value
                               ,g_tool_const_function
                               ,'(' || i_function_value || ')') || ')';
         
         ELSIF nvl(l_precedent, '?') = 'FUNCTION'
         THEN
            l_return := REPLACE(i_function_value
                               ,g_tool_const_lookup
                               ,'(' || i_lookup_value || ')');
         ELSE
            NULL;
         END IF;
         --     
         IF i_array_value IS NOT NULL
         THEN
            IF fn_exists_in_string(i_string         => i_array_value
                                  ,i_check_for_this => g_tool_const_function)
               OR
               fn_exists_in_string(i_string         => i_array_value
                                  ,i_check_for_this => g_tool_const_lookup)
            THEN
               l_return := REPLACE(i_array_value
                                  ,g_tool_const_lookup
                                  ,'(' || i_lookup_value || ')');
               l_return := REPLACE(l_return
                                  ,g_tool_const_function
                                  ,'(' || i_function_value || ')');
               l_return := REPLACE(l_return
                                  ,g_tool_const_lookup
                                  ,'(' || i_lookup_value || ')');
            END IF;
         END IF;
         --
         IF l_return IS NULL
         THEN
            IF i_function_value IS NOT NULL
               AND ((i_lookup_value IS NOT NULL) OR
               (i_array_value IS NOT NULL))
            THEN
               ex_cannot_choose_fn_or_lk;
            END IF;
            --
            -- If haven't got a return value then we need to choose one of the 3 thats not null.
            IF i_function_value IS NOT NULL
            THEN
               l_return := i_function_value;
            ELSIF i_lookup_value IS NOT NULL
            THEN
               l_return := '(' || i_lookup_value || ')';
            ELSIF i_array_value IS NOT NULL
            THEN
               l_return := i_array_value;
            END IF;
         END IF;
         -- 
      END IF;
      --
      RETURN l_return;
   END fn_process_pec_buf;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_mapping_col_or_value
   (
      i_batch                 IN NUMBER
     ,i_document              IN VARCHAR2
     ,i_relationship_group_id IN NUMBER
     ,i_mr_group              IN VARCHAR2
     ,i_nv_pair_tab           IN t_nv_pair_tab
     ,i_staged_schema         IN VARCHAR2
     ,i_utility_field_1       IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_2       IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_3       IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_4       IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_5       IN VARCHAR2 DEFAULT NULL
     ,i_introspect_step       IN VARCHAR2 DEFAULT NULL
     ,i_debug_mode            IN VARCHAR2
     ,i_json_line             IN VARCHAR2
   ) RETURN VARCHAR2 IS
      cur_pec_buf t_rec_pec_fla;
      --
      l_idx VARCHAR2(128);
      --
      l_return VARCHAR2(32767) := NULL;
      l_count  PLS_INTEGER;
   
      l_idx_tab_dot_col VARCHAR2(61);
      l_idx_2           PLS_INTEGER;
      l_tab_mapped      t_tab;
      --
      l_pem_idx_counter PLS_INTEGER;
      l_pem_buf         r_rec_pem;
      --
      const_intro_map_col CONSTANT VARCHAR2(30) := 'get mapping col/val end to end'; /* Monitor the end to end performance of this function. */
      --
   BEGIN
      IF i_introspect_step IS NOT NULL
      THEN
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_map_col
                                                       ,i_mode                   => 'START');
      END IF;
      cur_pec_buf := fn_get_command_comments(i_relationship_group_id => i_relationship_group_id
                                            ,i_mr_group              => i_mr_group);
      --
      l_return := fn_process_pec_buf(i_relationship_group_id => i_relationship_group_id
                                    ,i_mr_group              => i_mr_group
                                    ,i_function_value        => cur_pec_buf.function_value
                                    ,i_lookup_value          => cur_pec_buf.lookup_value
                                    ,i_array_value           => cur_pec_buf.array_value);
   
      /*---------------------------------------------------------------------------------
      *
      * This next piece replaces all the :MAPPED's with the TABLE.COLUMN names from 
      * the mapping tool.
      *
      *
      *---------------------------------------------------------------------------------
      */
      l_idx := to_char(i_relationship_group_id) || '/' || i_mr_group || '/' ||
               i_staged_schema || '/' || to_char(i_batch);
      IF g_tab_mapped_cache.EXISTS(l_idx)
      THEN
         l_tab_mapped := g_tab_mapped_cache(l_idx).mapped_cache;
         l_return     := g_tab_mapped_cache(l_idx).return_string;
      ELSE
         l_count           := 0;
         l_pem_idx_counter := 1;
         IF g_cache_pem.EXISTS(i_relationship_group_id || '/' ||
                               i_mr_group || '/' || l_pem_idx_counter)
         THEN
            LOOP
               l_pem_buf := g_cache_pem(i_relationship_group_id || '/' ||
                                        i_mr_group || '/' ||
                                        l_pem_idx_counter);
               -- we are looping backwards thru the mapped columns (because we need to do the highest mappings first)
               -- otherwise we might map :mapped#10 with the values from :mapped#1 (because they start with the same characters).
               IF l_count = 0
               THEN
                  l_count := (l_pem_buf.cnt + 1);
               END IF;
               l_count           := l_count - 1;
               l_return := REPLACE(l_return
                                  ,g_tool_const_mapped || (CASE
                                      WHEN l_pem_buf.cnt > 1 THEN
                                       '#' || to_char(l_count)
                                      ELSE
                                       NULL
                                   END)
                                  ,l_pem_buf.table_name || '.' ||
                                   l_pem_buf.column_name);
               l_idx_tab_dot_col := upper(l_pem_buf.table_name || '.' ||
                                          l_pem_buf.column_name);
               BEGIN
                  l_tab_mapped(l_idx_tab_dot_col) := g_nv_pos_cache(l_idx_tab_dot_col); /* indicates column has been used and links the true position */
               EXCEPTION
                  WHEN no_data_found THEN
                     raise_application_error(-20000
                                            ,'Cannot locate source for : ' ||
                                             l_idx_tab_dot_col ||
                                             ' - Check the table is correctly included in the migration definition, or that the target JSON is mapped correctly.');
               END;
               --
               IF l_pem_buf.cnt = l_pem_idx_counter
               THEN
                  EXIT;
               END IF;
               l_pem_idx_counter := l_pem_idx_counter + 1;
            END LOOP;
            --
            l_return := REPLACE(l_return
                               ,g_tool_const_src
                               ,fn_contextualize(i_subject => i_staged_schema
                                                ,i_context => g_run_context));
         
            l_return := REPLACE(l_return
                               ,g_tool_const_batch
                               ,to_char(i_batch));
            --
            g_tab_mapped_cache(l_idx).mapped_cache := l_tab_mapped;
            g_tab_mapped_cache(l_idx).return_string := l_return;
         
         END IF;
      END IF;
   
      -- Utility Fields 1 thru 5
      -- If there are any utility fields then replace them all accordingly.
      -- This kind replacement CANNOT be cached because they vary from row to row.
      IF fn_exists_in_string(i_string         => l_return
                            ,i_check_for_this => g_tool_const_uf)
      THEN
         l_return := REPLACE(l_return
                            ,g_tool_const_uf_1
                            ,chr(39) || i_utility_field_1 || chr(39));
         l_return := REPLACE(l_return
                            ,g_tool_const_uf_2
                            ,chr(39) || i_utility_field_2 || chr(39));
         l_return := REPLACE(l_return
                            ,g_tool_const_uf_3
                            ,chr(39) || i_utility_field_3 || chr(39));
         l_return := REPLACE(l_return
                            ,g_tool_const_uf_4
                            ,chr(39) || i_utility_field_4 || chr(39));
         l_return := REPLACE(l_return
                            ,g_tool_const_uf_5
                            ,chr(39) || i_utility_field_5 || chr(39));
      END IF;
   
      l_return := REPLACE(l_return, g_tool_const_mapped, NULL);
      --
      l_idx_tab_dot_col := l_tab_mapped.FIRST;
   
      -- These next replacements change the TABLE.COLUMN name into an actual value.
      -- This kind replacement CANNOT realistically be cached because they vary 
      -- from row to row.
      WHILE l_idx_tab_dot_col IS NOT NULL
      LOOP
         l_idx_2           := l_tab_mapped(l_idx_tab_dot_col);
         l_return          := REPLACE(l_return
                                     ,i_nv_pair_tab(l_idx_2).name
                                     ,nvl(i_nv_pair_tab(l_idx_2).value
                                         ,'NULL'));
         l_idx_tab_dot_col := l_tab_mapped.next(l_idx_tab_dot_col);
      END LOOP;
      --
      IF l_return IS NULL
      THEN
         l_return := 'NULL';
      END IF;
      --
      IF i_introspect_step IS NOT NULL
      THEN
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_map_col
                                                       ,i_mode                   => 'END');
      END IF;
      --
      --
      -- Add a comment to indicate which JSON value is being setup.
      IF i_debug_mode = 'TRUE'
      THEN
         RETURN '/*' || fn_get_attribute(i_line                     => i_json_line
                                        ,i_suppress_get_col_name_vc => 'TRUE') || '*/ ' || l_return;
      ELSE
         RETURN l_return;
      END IF;
   END fn_get_mapping_col_or_value;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_value_type(i_json_line IN VARCHAR2) RETURN VARCHAR2 IS
   BEGIN
      RETURN(CASE WHEN substr(i_json_line, -2, 2) LIKE '%"%' THEN
             'CHAR' WHEN
             upper(substr(i_json_line, -6, 6)) LIKE '%FALSE%' OR
             upper(substr(i_json_line, -6, 6)) LIKE '%TRUE%' THEN
             'BOOLEAN' WHEN(substr(i_json_line, -2, 2) LIKE '%{%' OR
                  substr(i_json_line, -2, 2) LIKE '%[%') THEN NULL
             WHEN(substr(i_json_line, -2, 2) LIKE '%}%' OR
                  substr(i_json_line, -2, 2) LIKE '%]%') THEN NULL WHEN
             substr(i_json_line, -2, 2) LIKE '%:%' THEN NULL WHEN
             TRIM(i_json_line) IN ('{', '}', '[', ']', '},', '],') THEN NULL ELSE
             'NUMBER' END);
   END fn_get_value_type;

   ----------------------------------------------------------------------------

   FUNCTION fn_replace_example_value
   (
      i_json_line IN VARCHAR2
     ,i_with      IN VARCHAR2
   ) RETURN VARCHAR2 IS
   BEGIN
      RETURN REPLACE(i_json_line
                    ,rtrim(TRIM(REPLACE(i_json_line
                                       ,'"' ||
                                        pkg_pre_etl_tools.fn_get_attribute(i_json_line
                                                                          ,'FALSE')
                                       ,NULL))
                          ,',{}[]' || chr(13))
                    ,'" : ' || i_with);
   END fn_replace_example_value;

   ----------------------------------------------------------------------------

   FUNCTION fn_is_sub_doc_related_to_frag
   (
      i_mr_group      IN VARCHAR2
     ,i_document_name IN VARCHAR2
     ,i_line_number   IN NUMBER
   ) RETURN BOOLEAN IS
      CURSOR cur_rel_frag
      (
         c_mr_group      IN VARCHAR2
        ,c_document_name IN VARCHAR2
        ,c_line_number   IN NUMBER
      ) IS
         SELECT 'TRUE' is_related_to_fragment
           FROM pre_etl_related_json_lines perjl
           JOIN pre_etl_related_json_lines perjl2
             ON (perjl2.relationship_group_id =
                perjl.relationship_group_id AND
                perjl2.mr_group = perjl.mr_group)
           JOIN pre_etl_json_document pejd
             ON (pejd.document_name = perjl2.document_name AND
                pejd.document_type = 'STORED FRAGMENT')
           JOIN pre_etl_json_lines pejl
             ON (pejl.document_name = perjl.document_name AND
                pejl.line_number = perjl.line_number)
           JOIN pre_etl_json_lines pejl2
             ON (pejl2.document_name = perjl2.document_name AND
                pejl2.line_number = perjl2.line_number)
          WHERE perjl.document_name = c_document_name
            AND perjl.line_number = c_line_number
            AND perjl.mr_group = c_mr_group
            AND pkg_pre_etl_tools.fn_get_attribute(i_line                     => pejl.json_line
                                                  ,i_suppress_get_col_name_vc => 'TRUE') =
                pkg_pre_etl_tools.fn_get_attribute(i_line                     => pejl2.json_line
                                                  ,i_suppress_get_col_name_vc => 'TRUE')
            AND pejl.document_name != pejl2.document_name;
   
      cur_rel_frag_buf cur_rel_frag%ROWTYPE;
      l_return         BOOLEAN;
   BEGIN
      OPEN cur_rel_frag(c_mr_group      => i_mr_group
                       ,c_document_name => i_document_name
                       ,c_line_number   => i_line_number);
      FETCH cur_rel_frag
         INTO cur_rel_frag_buf;
      --
      IF nvl(cur_rel_frag_buf.is_related_to_fragment, 'FALSE') =
         'TRUE'
      THEN
         l_return := TRUE;
      ELSE
         l_return := FALSE;
      END IF;
      --
      CLOSE cur_rel_frag;
      --
      RETURN l_return;
   END fn_is_sub_doc_related_to_frag;
   ----------------------------------------------------------------------------

   FUNCTION fn_is_sub_doc_rel_to_frag_rs
   (
      i_mr_group      IN VARCHAR2
     ,i_document_name IN VARCHAR2
     ,i_line_number   IN NUMBER
   ) RETURN BOOLEAN result_cache IS
   BEGIN
      RETURN fn_is_sub_doc_related_to_frag(i_mr_group      => i_mr_group
                                          ,i_document_name => i_document_name
                                          ,i_line_number   => i_line_number);
   END fn_is_sub_doc_rel_to_frag_rs;
   ----------------------------------------------------------------------------

   FUNCTION fn_has_code_in_comment
   (
      i_mr_group      IN VARCHAR2
     ,i_document_name IN VARCHAR2
     ,i_line_number   IN NUMBER
   ) RETURN VARCHAR2 IS
      l_return VARCHAR2(5);
   BEGIN
      SELECT has_code_comment
        INTO l_return
        FROM (SELECT 'TRUE' has_code_comment
                FROM pre_etl_json_lines pejl
                JOIN pre_etl_related_json_lines perjl
                  ON (perjl.document_name = pejl.document_name AND
                     perjl.line_number = pejl.line_number AND
                     perjl.mr_group = i_mr_group)
                JOIN pre_etl_comments pec
                  ON (pec.relationship_group_id =
                     perjl.relationship_group_id AND
                     pec.mr_group = i_mr_group AND
                     decode(decode(pec.comment_type
                                   ,'V'
                                   ,'A'
                                   ,pec.comment_type)
                            ,'F'
                            ,decode(substr(CAST(pec.comments AS
                                                VARCHAR2(32000))
                                          ,1
                                          ,1)
                                   ,'='
                                   ,1
                                   ,0)
                            ,'L'
                            ,decode(upper(substr(CAST(pec.comments AS
                                                      VARCHAR2(32000))
                                                ,1
                                                ,6))
                                   ,'SELECT'
                                   ,1
                                   ,decode(upper(substr(CAST(pec.comments AS
                                                             VARCHAR2(32000))
                                                       ,1
                                                       ,4))
                                          ,'WITH'
                                          ,1
                                          ,0))
                            ,'A'
                            ,decode(upper(substr(CAST(pec.comments AS
                                                      VARCHAR2(32000))
                                                ,1
                                                ,6))
                                   ,'SELECT'
                                   ,1
                                   ,decode(upper(substr(CAST(pec.comments AS
                                                             VARCHAR2(32000))
                                                       ,1
                                                       ,4))
                                          ,'WITH'
                                          ,1
                                          ,0))
                            ,0) = 1)
               WHERE pejl.document_name = i_document_name
                 AND pejl.line_number = i_line_number
              UNION
              SELECT 'FALSE'
                FROM dual
               ORDER BY 1 DESC)
       WHERE rownum = 1;
      --
      RETURN l_return;
   
   END fn_has_code_in_comment;

   ----------------------------------------------------------------------------

   FUNCTION fn_related_frag
   (
      i_mr_group      IN VARCHAR2
     ,i_document_name IN VARCHAR2
     ,i_line_number   IN NUMBER
   ) RETURN VARCHAR2 result_cache IS
      CURSOR cur_rel_frag
      (
         c_mr_group      IN VARCHAR2
        ,c_document_name IN VARCHAR2
        ,c_line_number   IN NUMBER
      ) IS
         SELECT pejd.document_name
           FROM pre_etl_related_json_lines perjl
           JOIN pre_etl_related_json_lines perjl2
             ON (perjl2.relationship_group_id =
                perjl.relationship_group_id AND
                perjl2.mr_group = perjl.mr_group)
           JOIN pre_etl_json_document pejd
             ON (pejd.document_name = perjl2.document_name AND
                pejd.document_type = 'STORED FRAGMENT')
           JOIN pre_etl_json_lines pejl
             ON (pejl.document_name = perjl.document_name AND
                pejl.line_number = perjl.line_number)
           JOIN pre_etl_json_lines pejl2
             ON (pejl2.document_name = perjl2.document_name AND
                pejl2.line_number = perjl2.line_number)
          WHERE perjl.document_name = c_document_name
            AND perjl.line_number = c_line_number
            AND perjl.mr_group = c_mr_group
            AND pkg_pre_etl_tools.fn_get_attribute(i_line                     => pejl.json_line
                                                  ,i_suppress_get_col_name_vc => 'TRUE') =
                pkg_pre_etl_tools.fn_get_attribute(i_line                     => pejl2.json_line
                                                  ,i_suppress_get_col_name_vc => 'TRUE')
            AND pejl.document_name != pejl2.document_name
            AND pejl2.line_number = 1;
   
      cur_rel_frag_buf cur_rel_frag%ROWTYPE;
   BEGIN
      OPEN cur_rel_frag(c_mr_group      => i_mr_group
                       ,c_document_name => i_document_name
                       ,c_line_number   => i_line_number);
      FETCH cur_rel_frag
         INTO cur_rel_frag_buf;
      CLOSE cur_rel_frag;
      --
      RETURN cur_rel_frag_buf.document_name;
   END fn_related_frag;

   ----------------------------------------------------------------------------
   FUNCTION fn_get_document_type(i_document_name IN VARCHAR2)
      RETURN VARCHAR2 result_cache IS
   
      CURSOR cur_pejd(c_document_name IN VARCHAR2) IS
         SELECT pejd.document_type
           FROM pre_etl_json_document pejd
          WHERE pejd.document_name = c_document_name;
   
      cur_pejd_buf cur_pejd%ROWTYPE;
   BEGIN
      OPEN cur_pejd(c_document_name => i_document_name);
      FETCH cur_pejd
         INTO cur_pejd_buf;
      CLOSE cur_pejd;
      RETURN cur_pejd_buf.document_type;
   END fn_get_document_type;

   -------------------------------------------------------------------------------

   FUNCTION fn_allow_relationship
   (
      i_mr_group              IN VARCHAR2
     ,i_adding_to_document    IN VARCHAR2
     ,i_adding_to_line_number IN NUMBER
     ,i_relate_to_document    IN VARCHAR2
     ,i_relate_to_line_number IN NUMBER
   ) RETURN BOOLEAN IS
      l_return_bool BOOLEAN := TRUE;
   
      FUNCTION fn_has_relations_to_stored
      (
         i_document_name IN VARCHAR2
        ,i_line_number   IN NUMBER
        ,i_mr_group      IN VARCHAR2
        ,i_type          IN VARCHAR2
      ) RETURN BOOLEAN IS
      
         CURSOR cur_perjl_pejd
         (
            c_document_name IN VARCHAR2
           ,c_line_number   IN NUMBER
           ,c_mr_group      IN VARCHAR2
           ,c_type          IN VARCHAR2
         ) IS
            SELECT *
              FROM pre_etl_related_json_lines perjl
              JOIN pre_etl_json_document pejd
                ON (pejd.document_name = perjl.document_name)
             WHERE perjl.mr_group = c_mr_group
               AND perjl.relationship_group_id IN
                   (SELECT perjl2.relationship_group_id
                      FROM pre_etl_related_json_lines perjl2
                     WHERE perjl2.mr_group = c_mr_group
                       AND perjl2.document_name = c_document_name
                       AND perjl2.line_number = c_line_number)
               AND pejd.document_type = c_type
               AND perjl.document_name != c_document_name
               AND rownum = 1;
      
         cur_perjl_pejd_buf cur_perjl_pejd%ROWTYPE;
         l_return_bool      BOOLEAN;
      BEGIN
         OPEN cur_perjl_pejd(c_document_name => i_document_name
                            ,c_line_number   => i_line_number
                            ,c_mr_group      => i_mr_group
                            ,c_type          => i_type);
         FETCH cur_perjl_pejd
            INTO cur_perjl_pejd_buf;
         l_return_bool := cur_perjl_pejd%FOUND;
         CLOSE cur_perjl_pejd;
         --
         RETURN l_return_bool;
      END fn_has_relations_to_stored;
   
   BEGIN
   
      -- If we are adding a relationship to a Stored Fragment (SF-1) to another Stored Fragment (SF-2) and the line number 
      -- we are  adding it to (in SF-1) is already related to 1 or more stored document(s) then we must reject the addition
      -- of the Stored Fragment (SF-2)
   
      -- If we are adding a relationship to a Stored Fragment (SF-1) to another Stored Fragment (SF-2) and the line number 
      -- we are adding (in SF-2) is already related to 1 or more stored document(s) then we must reject the addition
      -- of the Stored Fragment (SF-2)
   
      -- If we are adding a relationship to a Stored Document (SD-1) to a Stored Fragment (SF) and the line number in the
      -- Stored Fragment (SF) is related to 1 or more Stored Fragment(s) then we must reject the addition of the 
      -- Stored Fragment (SF) 
      --
      -- If we are adding a relationship to a Stored Document (SD-1) to a Stored Fragment (SF) and the line number in the
      -- Stored Document (SD-1) is related to 1 or more Stored Fragment(s) then we must reject the addition of the 
      -- Stored Fragment (SF)       
      --
      IF fn_get_document_type(i_document_name => i_adding_to_document) =
         'STORED FRAGMENT'
      THEN
         IF fn_get_document_type(i_document_name => i_relate_to_document) =
            'STORED FRAGMENT'
         THEN
            IF fn_has_relations_to_stored(i_document_name => i_adding_to_document
                                         ,i_line_number   => i_adding_to_line_number
                                         ,i_mr_group      => i_mr_group
                                         ,i_type          => 'STORED DOCUMENT')
               OR
               fn_has_relations_to_stored(i_document_name => i_relate_to_document
                                         ,i_line_number   => i_relate_to_line_number
                                         ,i_mr_group      => i_mr_group
                                         ,i_type          => 'STORED DOCUMENT')
            THEN
               l_return_bool := FALSE;
            ELSE
               l_return_bool := TRUE;
            END IF;
         END IF;
      END IF;
      --
      IF l_return_bool
      THEN
         IF fn_get_document_type(i_document_name => i_adding_to_document) =
            'STORED DOCUMENT'
         THEN
            IF fn_get_document_type(i_document_name => i_relate_to_document) =
               'STORED FRAGMENT'
            THEN
               IF fn_has_relations_to_stored(i_document_name => i_relate_to_document
                                            ,i_line_number   => i_relate_to_line_number
                                            ,i_mr_group      => i_mr_group
                                            ,i_type          => 'STORED FRAGMENT')
                  OR
                  fn_has_relations_to_stored(i_document_name => i_adding_to_document
                                            ,i_line_number   => i_adding_to_line_number
                                            ,i_mr_group      => i_mr_group
                                            ,i_type          => 'STORED FRAGMENT')
               THEN
                  l_return_bool := FALSE;
               ELSE
                  l_return_bool := TRUE;
               END IF;
            END IF;
         END IF;
      END IF;
      --
      RETURN l_return_bool;
   END fn_allow_relationship;

   ----------------------------------------------------------------------------
   -- It possible to access text from the captured JSON line notes.
   -- by replacing $$xyz$$
   FUNCTION fn_replace_dollar_dollar
   (
      i_string                       IN VARCHAR2
     ,i_remove_external_reftags_bool IN BOOLEAN DEFAULT TRUE
   ) RETURN VARCHAR2 IS
      TYPE r_rec IS RECORD(
          key   VARCHAR2(500)
         ,VALUE VARCHAR2(2000));
      TYPE t_tab_ln IS TABLE OF r_rec INDEX BY BINARY_INTEGER;
      l_tab_ln t_tab_ln;
      --
      TYPE t_tab IS TABLE OF VARCHAR2(500) INDEX BY BINARY_INTEGER;
      l_tab     t_tab;
      l_tab_idx PLS_INTEGER := 0;
      l_pos1    PLS_INTEGER := 1;
      l_pos2    PLS_INTEGER;
      --
      l_return VARCHAR2(32767) := i_string;
      --
      FUNCTION fn_get_replacement(i_key IN VARCHAR2) RETURN VARCHAR2 IS
      BEGIN
         IF l_tab_ln.COUNT > 0
         THEN
            FOR i IN l_tab_ln.FIRST .. l_tab_ln.LAST
            LOOP
               IF l_tab_ln(i).key = i_key
               THEN
                  RETURN l_tab_ln(i).value;
               END IF;
            END LOOP;
         END IF;
         --
         RETURN i_key;
      END fn_get_replacement;
   BEGIN
      IF i_string IS NOT NULL
      THEN
         -- Get a list of the $$<xyz>$$ replaceables.
         -- 
         WHILE TRUE
         LOOP
            l_pos1 := instr(i_string, '$$', l_pos1);
            IF l_pos1 = 0
            THEN
               EXIT;
            ELSE
               l_tab_idx := l_tab_idx + 1;
               l_pos2 := instr(i_string, '$$', l_pos1 + 1);
               l_tab(l_tab_idx) := upper(substr(i_string
                                               ,l_pos1
                                               ,(l_pos2 - l_pos1) + 2));
               l_pos1 := l_pos2 + 1;
            END IF;
         END LOOP;
         --
         SELECT '$$' ||
                upper(t.document_name || '.' ||
                      pkg_pre_etl_tools.fn_get_attribute(t.json_line
                                                        ,'FALSE')) || '$$' key
               ,t.comments
           BULK COLLECT
           INTO l_tab_ln
           FROM pre_etl_json_lines t
          WHERE t.comments IS NOT NULL;
         --
         IF l_tab.COUNT > 0
         THEN
            FOR i IN l_tab.FIRST .. l_tab.LAST
            LOOP
               l_return := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => i_string
                                                                              ,i_keyword   => l_tab(i))
                                  ,l_tab(i)
                                  ,fn_get_replacement(i_key => l_tab(i)));
            END LOOP;
         END IF;
         --
      END IF;
      -- External reftags are how we reference fields BEYOND the table we're processing (probably a view table for example).
      IF i_remove_external_reftags_bool
      THEN
         RETURN REPLACE(REPLACE(l_return, '<!', NULL), '!>', NULL);
      ELSE
         RETURN l_return;
      END IF;
   END fn_replace_dollar_dollar;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_json_for_table
   (
      i_table_name                  IN VARCHAR2
     ,i_schema_name                 IN VARCHAR2
     ,i_included_extended_data_bool IN BOOLEAN DEFAULT TRUE
   ) RETURN t_vc_tab IS
      l_clob  CLOB := '  {' || chr(10);
      l_count PLS_INTEGER := 0;
   BEGIN
      FOR i_buf IN (SELECT atc.table_name
                          ,CASE
                              WHEN atc.owner LIKE '%/_MCP/_%' ESCAPE '/' THEN
                               substr(atc.owner
                                     ,instr(atc.owner, '_MCP_') + 1)
                              ELSE
                               atc.owner
                           END AS owner
                          ,lower(atc.column_name) AS column_name
                          ,lower(atc.data_type) AS data_type
                          ,decode(atc.char_length
                                 ,0
                                 ,atc.data_length
                                 ,atc.char_length) AS data_length
                          ,row_number() over(ORDER BY column_id) AS col_number
                          ,COUNT(*) over() AS total_cols
                      FROM all_tab_cols atc
                     WHERE atc.table_name = upper(i_table_name)
                       AND atc.owner = upper(i_schema_name)
                       AND atc.table_name NOT LIKE 'PLSQL_%'
                       AND atc.table_name NOT LIKE 'JSON_TAB%'
                       AND atc.column_id IS NOT NULL
                     ORDER BY atc.column_id)
      LOOP
         IF l_count = 0
         THEN
            dbms_lob.append(l_clob
                           ,'    ' || '"TABLE_NAME" : "' ||
                            i_buf.table_name || '",' || chr(10));
            dbms_lob.append(l_clob
                           ,'    ' || '"SCHEMA_NAME" : "' ||
                            i_buf.owner || '",' || chr(10));
            dbms_lob.append(l_clob
                           ,'    ' || '"COLUMNS" :' || chr(10));
            dbms_lob.append(l_clob, '    ' || '[' || chr(10));
         END IF;
         l_count := l_count + 1;
         dbms_lob.append(l_clob, '      {' || chr(10));
         dbms_lob.append(l_clob
                        ,'        "COLUMN_NAME" : "' ||
                         i_buf.column_name ||
                         (CASE i_included_extended_data_bool WHEN TRUE THEN '",' ELSE '"' END) ||
                         chr(10));
         IF i_included_extended_data_bool
         THEN
            dbms_lob.append(l_clob
                           ,'        "DATA_TYPE" : "' ||
                            i_buf.data_type || '",' || chr(10));
            dbms_lob.append(l_clob
                           ,'        "DATA_LENGTH" : "' ||
                            i_buf.data_length || '"' || chr(10));
         END IF;
         dbms_lob.append(l_clob
                        ,'      }' ||
                         (CASE WHEN
                          i_buf.total_cols = i_buf.col_number THEN NULL ELSE ',' END) ||
                         chr(10));
      END LOOP;
      --
      dbms_lob.append(l_clob, '    ' || ']' || chr(10));
      dbms_lob.append(l_clob, '  }' || chr(10));
      RETURN fn_cut_clob_to_tab(i_clob => l_clob);
   END fn_get_json_for_table;

   ----------------------------------------------------------------------------

   FUNCTION fn_add_hint
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN VARCHAR2 result_cache IS
      l_return pre_etl_migration_run_hint.hint%TYPE;
   BEGIN
      SELECT decode(pemrh.hint
                   ,NULL
                   ,NULL
                   ,rtrim(TRIM(pemrh.hint), '*/') ||
                    ' no_parallel */')
        INTO l_return
        FROM pre_etl_migration_run_hint pemrh
       WHERE pemrh.migration_group = i_migration_group
         AND pemrh.migration_name = i_migration_name;
      --
      RETURN l_return || fn_lf || '          ';
   EXCEPTION
      WHEN no_data_found THEN
         RETURN '/*+no_parallel */' || fn_lf || '          ';
   END fn_add_hint;

   ----------------------------------------------------------------------------

   FUNCTION fn_tab_doc_incl_with_clause
   (
      i_mr_group              IN VARCHAR2
     ,i_relationship_group_id IN NUMBER
   ) RETURN BOOLEAN IS
      CURSOR cur_check_for_with
      (
         c_mr_group              IN VARCHAR2
        ,c_relationship_group_id IN NUMBER
      ) IS
         SELECT NULL
           FROM pre_etl_related_json_lines perjl
           JOIN pre_etl_comments pec
             ON (pec.mr_group = perjl.mr_group AND
                pec.relationship_group_id =
                perjl.relationship_group_id AND
                pec.comment_type = 'L')
           JOIN pre_etl_json_document pejd
             ON (pejd.document_name = perjl.document_name AND
                pejd.document_type = 'TABLE DOCUMENT')
          WHERE perjl.mr_group = c_mr_group
            AND perjl.relationship_group_id = c_relationship_group_id
            AND upper(pec.comments) LIKE 'WITH%'
            AND rownum = 1;
      cur_check_for_with_buf cur_check_for_with%ROWTYPE;
      l_return               BOOLEAN;
   BEGIN
      -- We mustn't allow users to set up WITH clauses on related LOOKUPS if one of the related documents
      -- is a TABLE type document.
      -- This function can be used to check for that scenario.
      OPEN cur_check_for_with(c_mr_group              => i_mr_group
                             ,c_relationship_group_id => i_relationship_group_id);
      FETCH cur_check_for_with
         INTO cur_check_for_with_buf;
      l_return := cur_check_for_with%FOUND;
      CLOSE cur_check_for_with;
      --
      RETURN l_return;
   
   END fn_tab_doc_incl_with_clause;

   ----------------------------------------------------------------------------

   PROCEDURE pr_get_pedc2
   (
      i_search      IN VARCHAR2
     ,i_next        IN NUMBER
     ,o_col1        OUT VARCHAR2
     ,o_col2        OUT VARCHAR2
     ,o_col4        OUT VARCHAR2
     ,o_rn          OUT NUMBER
     ,o_cnt         OUT NUMBER
     ,o_search_item OUT NUMBER
   ) IS
      l_buf cur_pedc2%ROWTYPE;
   BEGIN
      l_buf         := fn_get_pedc2(i_search => i_search
                                   ,i_next   => i_next);
      o_col1        := l_buf.col1;
      o_col2        := l_buf.col2;
      o_col4        := l_buf.col4;
      o_rn          := l_buf.rn;
      o_cnt         := l_buf.cnt;
      o_search_item := l_buf.search_item;
   END pr_get_pedc2;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_fragment_cache IS
   BEGIN
      g_cache_json_fragments.delete;
   END pr_clear_fragment_cache;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_intra_clear IS
   BEGIN
      g_json_intra_clear.delete;
   END pr_clear_intra_clear;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_sql_array_debug IS
   BEGIN
      g_sql_array_debug.delete;
   END pr_clear_sql_array_debug;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_nv_pos_cache(i_nv_pair_tab IN t_nv_pair_tab) IS
   BEGIN
      -- Capture the positions of the table.column names for performance 
      -- in fn_get_mapping_col_or_value
      g_nv_pos_cache.delete;
      IF i_nv_pair_tab.COUNT > 0
      THEN
         FOR i IN i_nv_pair_tab.FIRST .. i_nv_pair_tab.LAST
         LOOP
            g_nv_pos_cache(upper(i_nv_pair_tab(i).name)) := i;
         END LOOP;
      END IF;
   END pr_clear_nv_pos_cache;

   ----------------------------------------------------------------------------

   PROCEDURE pr_add_to_intra_clear(i_clear_this IN VARCHAR2) IS
   BEGIN
      -- we use the index for the thing we want to clear;
      g_json_intra_clear(i_clear_this) := 'X';
   END pr_add_to_intra_clear;

   ----------------------------------------------------------------------------

   FUNCTION fn_tab_func_doc_by_example
   (
      i_batch               IN NUMBER
     ,i_document            IN VARCHAR2
     ,i_mr_group            IN VARCHAR2
     ,i_mig_group           IN VARCHAR2
     ,i_nv_pair_tab         IN t_nv_pair_tab
     ,i_replace_values_tab  IN t_json_replace_tab
     ,i_staged_schema       IN VARCHAR2
     ,i_skip_mapping        IN VARCHAR2 DEFAULT 'FALSE'
     ,i_use_smart_cache     IN VARCHAR2
     ,i_smart_cache_index   IN VARCHAR2
     ,i_smart_cache_attrs   IN VARCHAR2
     ,i_smart_cache_usecase IN NUMBER
     ,i_fragment_insertion  IN VARCHAR2
     ,i_origin              IN NUMBER
     ,i_utility_field_1     IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_2     IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_3     IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_4     IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_5     IN VARCHAR2 DEFAULT NULL
     ,i_introspect_step     IN VARCHAR2 DEFAULT NULL
     ,i_debug_mode          IN VARCHAR2 DEFAULT 'FALSE'
     ,i_docbyexample_tab    IN t_docbyexample_tab DEFAULT t_docbyexample_tab()
   ) RETURN t_docbyexample_tab AS
      l_docbyexample_tab         t_docbyexample_tab := i_docbyexample_tab;
      l_json                     VARCHAR2(32767);
      l_sql                      VARCHAR2(32767);
      l_evaluate                 VARCHAR2(32767);
      l_evaluate_char_true_false VARCHAR2(5);
      l_dynamic_select           VARCHAR2(32767);
      l_mapping                  VARCHAR2(32767);
      l_end_like                 VARCHAR2(500);
      l_cache_fragment_idx       VARCHAR2(500);
      l_addition                 VARCHAR2(1);
      l_pad_length               PLS_INTEGER;
      l_skip_lines_bool          BOOLEAN := FALSE;
      l_doc                      VARCHAR2(128);
      l_buf                      t_rec_pejl;
      l_origin                   NUMBER;
      l_count                    NUMBER := 0;
      l_introspection            VARCHAR2(50) := 'Pipelined Function : Use Case : ' ||
                                                 i_smart_cache_usecase;
      const_intro_array_insertion CONSTANT VARCHAR2(30) := 'Array Insertion'; /* Monitor Array Insertion. */
      const_intro_fragment_eval   CONSTANT VARCHAR2(30) := 'Fragment Evaluation'; /* Monitor Fragment Evaluation. */
      --
      l_depth INTEGER;
      --
      PROCEDURE pr_pipe_row(i_row IN t_docbyexample_row) IS
      BEGIN
         l_docbyexample_tab.extend;
         l_docbyexample_tab(l_docbyexample_tab.COUNT) := i_row;
      END pr_pipe_row;
      --
      -- LOCAL FUNCTION...
      FUNCTION fn_smart_cache
      (
         i_row                 IN t_docbyexample_row
        ,i_smart_cache_index   IN VARCHAR2
        ,i_use_smart_cache     IN VARCHAR2
        ,i_smart_cache_usecase IN NUMBER
        ,i_origin              IN NUMBER
      ) RETURN t_docbyexample_row IS
         l_with            VARCHAR2(32767);
         l_manipulated_row t_docbyexample_row;
      BEGIN
         l_manipulated_row := i_row;
         --
         IF i_smart_cache_usecase = g_const_usecase_replace_vals
         THEN
            --
            IF i_row.verbatim_yn != 'Y'
            THEN
               l_count := l_count + 1;
               l_with  := (CASE
                           i_replace_values_tab(l_count).field_type
                             WHEN 'CHAR' THEN
                              '"' || TRIM(i_replace_values_tab(l_count)
                                          .char_value) || '"'
                             WHEN 'BOOLEAN' THEN
                              TRIM(i_replace_values_tab(l_count)
                                   .char_value)
                             ELSE
                              to_char(i_replace_values_tab(l_count)
                                      .number_value)
                          END);
               IF nvl(i_replace_values_tab(l_count).field_type
                     ,'JSON SCHEMA CONTROL') IN
                  ('CHAR', 'BOOLEAN', 'NUMBER')
                  AND l_with IS NULL
                  OR l_with = '""'
               THEN
                  -- If there is no value expressed then we will remove the JSON line.
                  l_manipulated_row.json_line := NULL;
               ELSE
                  l_manipulated_row.json_line := TRIM(fn_replace_example_value(i_json_line => l_manipulated_row.json_line
                                                                              ,i_with      => l_with));
               END IF;
            END IF;
         END IF;
      
         IF i_smart_cache_index IS NOT NULL
            AND i_use_smart_cache = 'FALSE'
         THEN
            g_piped_line := g_piped_line + 1;
            --
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('Storing smart cache line : ' ||
                              i_smart_cache_index || '/' ||
                              i_smart_cache_usecase || '/' ||
                              i_origin || '/' || g_piped_line);
            END IF;
            --
            -- Almost the same but Verbatim is always "Y" 
            g_tab_json_smart_cache(i_smart_cache_index)(i_smart_cache_usecase)(i_origin)(g_piped_line) := t_docbyexample_row(json_line             => l_manipulated_row.json_line
                                                                                                                            ,verbatim_yn           => 'Y'
                                                                                                                            ,mr_group              => l_manipulated_row.mr_group
                                                                                                                            ,relationship_group_id => l_manipulated_row.relationship_group_id
                                                                                                                            ,mapping               => l_manipulated_row.mapping);
         END IF;
         --
         RETURN l_manipulated_row;
      EXCEPTION
         WHEN OTHERS THEN
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('pkg_pre_etl_tools.fn_smart_cache : ' ||
                              SQLERRM);
            END IF;
            RAISE;
      END fn_smart_cache;
      --
      -- LOCAL FUNCTION...
      FUNCTION fn_closed_with_comma
      (
         i_document    IN VARCHAR2
        ,i_line_number IN NUMBER
        ,i_end_like    IN VARCHAR2
      ) RETURN BOOLEAN result_cache IS
      BEGIN
         -- Some arrays are followed by other elements at the same level (in which case we need to add a comma)
         FOR i_buf IN (SELECT pejl.json_line
                         FROM pre_etl_json_lines pejl
                        WHERE pejl.document_name = i_document
                          AND pejl.line_number > i_line_number
                        ORDER BY pejl.line_number)
         LOOP
            IF i_buf.json_line LIKE i_end_like
            THEN
               IF substr(i_buf.json_line, -1, 1) = ','
               THEN
                  RETURN TRUE;
               ELSE
                  RETURN FALSE;
               END IF;
            END IF;
         END LOOP;
         -- catch all which we should never arrive at.
         RETURN FALSE;
      END fn_closed_with_comma;
      --
      -- LOCAL PROCEDURE...
      PROCEDURE pr_populate_cache
      (
         i_mr_group      IN VARCHAR2
        ,i_document_name IN VARCHAR2
      ) IS
      BEGIN
         SELECT pejl.json_line
               ,pejl.line_number
               ,perjl.relationship_group_id
               ,perjl.mr_group
               ,pec.comment_type
               ,CASE
                   WHEN MAX(pejl.line_number)
                    over() = pejl.line_number THEN
                    'Y'
                   ELSE
                    'N'
                END AS last_line_verbatim_yn
           BULK COLLECT
           INTO g_tab_of_t_tab_pejl(i_mr_group || ':' ||
                                    i_document_name)
           FROM pre_etl_json_lines pejl
           LEFT JOIN pre_etl_related_json_lines perjl
             ON (perjl.document_name = pejl.document_name AND
                perjl.line_number = pejl.line_number AND
                perjl.mr_group = i_mr_group)
           LEFT JOIN pre_etl_comments pec
             ON (pec.relationship_group_id =
                perjl.relationship_group_id AND
                pec.mr_group = perjl.mr_group AND
                pec.comment_type IN ('A', 'V'))
          WHERE pejl.document_name = i_document_name
          ORDER BY pejl.line_number;
      END pr_populate_cache;
      --
   BEGIN
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => l_introspection
                                                    ,i_mode                   => 'START');
      l_doc := i_mr_group || ':' || i_document;
      IF NOT g_tab_of_t_tab_pejl.EXISTS(l_doc)
      THEN
         pr_populate_cache(i_mr_group      => i_mr_group
                          ,i_document_name => i_document);
      END IF;
      --
      IF g_tab_of_t_tab_pejl(l_doc).COUNT = 0
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools : fn_tab_func_doc_by_example : Cannot find cache for ' ||
                                 l_doc);
      END IF;
      --
      FOR i IN g_tab_of_t_tab_pejl(l_doc).FIRST .. g_tab_of_t_tab_pejl(l_doc).LAST
      LOOP
         IF i_fragment_insertion = 'FALSE' -- Main docs are FALSE (only bits we inject are TRUE)
         THEN
            l_origin     := i;
            g_piped_line := 0; -- Any one line of Doc By Example can have multiple lines output because of it.  This keeps track fof the outbound lines.
         ELSE
            IF i_origin IS NULL
            THEN
               raise_application_error(-20000
                                      ,'pkg_pre_etl_tools.fn_tab_func_doc_by_example : i_origin is NULL.  Thats not expected for fragment insertion.');
            END IF;
            l_origin := i_origin;
         END IF;
      
         l_buf := g_tab_of_t_tab_pejl(l_doc) (i);
         --
         -- If we're using the smart cache and the attribute we're looking at from the "Document By Example"
         -- is NOT one of the "excluded from cache" (in other words it needs to be rebuilt) then repeat the
         -- same output as we performed last time.
         IF i_use_smart_cache = 'TRUE'
            AND
            instr(i_smart_cache_attrs
                 ,'"' ||
                  pkg_pre_etl_tools.fn_get_attribute(i_line                     => l_buf.json_line
                                                    ,i_suppress_get_col_name_vc => 'TRUE') || '"') = 0
         THEN
            --
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('SMART CACHE (starting) : ' ||
                              i_smart_cache_index || '/' ||
                              i_smart_cache_usecase || '/' ||
                              l_origin);
            END IF;
            --
            IF g_tab_json_smart_cache(i_smart_cache_index)(i_smart_cache_usecase)
            .EXISTS(l_origin)
            THEN
               IF g_tab_json_smart_cache(i_smart_cache_index)
                (i_smart_cache_usecase)(l_origin).COUNT > 0
               THEN
                  FOR i2 IN g_tab_json_smart_cache(i_smart_cache_index)
                            (i_smart_cache_usecase)(l_origin).FIRST .. g_tab_json_smart_cache(i_smart_cache_index)
                                                                       (i_smart_cache_usecase)(l_origin).LAST
                  LOOP
                     -- Piping out what we piped out previously. (try saying that when you've had a few too many).
                     pr_pipe_row(g_tab_json_smart_cache(i_smart_cache_index)
                                 (i_smart_cache_usecase) (l_origin) (i2));
                  END LOOP;
               END IF;
            END IF;
            --
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('SMART CACHE : Finished piping out previous cached lines...');
            END IF;
            --
         ELSE
            -- If we're handling an array SQL... or injected fragment.       
            IF (l_buf.comment_type IN ('A', 'V') OR
               (i != 1 AND
               substr(TRIM(l_buf.json_line), -1, 1) = ':' AND
               fn_is_sub_doc_rel_to_frag_rs(i_mr_group      => l_buf.mr_group
                                             ,i_document_name => i_document
                                             ,i_line_number   => l_buf.line_number)))
            THEN
               l_pad_length := greatest((instr(l_buf.json_line
                                              ,'"'
                                              ,1
                                              ,1) - 3)
                                       ,0);
               --
               -- For Arrays we always put out the start of the array subdoc.                                    
               IF l_buf.comment_type IN ('A', 'V')
               THEN
                  pr_pipe_row(fn_smart_cache(i_row                 => t_docbyexample_row(l_buf.json_line
                                                                                        ,'Y'
                                                                                        ,l_buf.mr_group
                                                                                        ,l_buf.relationship_group_id
                                                                                        ,'NULL')
                                            ,i_smart_cache_index   => i_smart_cache_index
                                            ,i_use_smart_cache     => i_use_smart_cache
                                            ,i_smart_cache_usecase => i_smart_cache_usecase
                                            ,i_origin              => l_origin));
               END IF;
               --
               l_skip_lines_bool := TRUE;
               --
               -- If we're in SQL Array handling then the "end" is always a close array.
               IF l_buf.comment_type IN ('A', 'V')
               THEN
                  -- Add to the intra clear the "blank" json line : eg "anArray":[] 
                  -- So we don't end up with rubbish cluttering the JSON for when arrays have no value.
                  pr_add_to_intra_clear(i_clear_this => '"' ||
                                                        pkg_pre_etl_tools.fn_get_attribute(i_line                     => l_buf.json_line
                                                                                          ,i_suppress_get_col_name_vc => 'TRUE') ||
                                                        '":[]');
                  --
                  l_end_like := substr(l_buf.json_line
                                      ,1
                                      ,instr(l_buf.json_line, '"') - 1) || ']%';
               ELSE
                  --
                  -- If we're in fragment injection handling then the "end" could be a close array or a close sub document.
                  IF pkg_pre_etl_tools.fn_is_next_line_array_start(i_document    => i_document
                                                                  ,i_line_number => l_buf.line_number)
                  THEN
                     pr_add_to_intra_clear(i_clear_this => '"' ||
                                                           pkg_pre_etl_tools.fn_get_attribute(i_line                     => l_buf.json_line
                                                                                             ,i_suppress_get_col_name_vc => 'TRUE') ||
                                                           '":[]');
                     --
                     l_end_like := substr(l_buf.json_line
                                         ,1
                                         ,instr(l_buf.json_line, '"') - 1) || ']%';
                  ELSE
                     pr_add_to_intra_clear(i_clear_this => '"' ||
                                                           pkg_pre_etl_tools.fn_get_attribute(i_line                     => l_buf.json_line
                                                                                             ,i_suppress_get_col_name_vc => 'TRUE') ||
                                                           '":{}');
                     --
                     l_end_like := substr(l_buf.json_line
                                         ,1
                                         ,instr(l_buf.json_line, '"') - 1) || '}%';
                  END IF;
               END IF;
               -- Some arrays/sub documents end with , ... ],  ... }, etc <--- we need to add that comma if necessary.
               IF fn_closed_with_comma(i_document    => i_document
                                      ,i_line_number => l_buf.line_number
                                      ,i_end_like    => l_end_like)
               THEN
                  l_addition := ',';
               ELSE
                  l_addition := NULL;
               END IF;
               --
               -- If we have been through here for this imported row then we need not assemble it again.
               -- we will get it from our cache.
               l_cache_fragment_idx := i_document || ':' ||
                                       to_char(l_buf.line_number);
               IF g_cache_json_fragments.EXISTS(l_cache_fragment_idx)
               THEN
                  IF i_debug_mode = 'TRUE'
                  THEN
                     pr_dbms_output('Cache of JSON fragment exists for :' ||
                                    l_buf.line_number);
                  END IF;
                  l_json := g_cache_json_fragments(l_cache_fragment_idx);
               ELSE
                  --
                  IF i_debug_mode = 'TRUE'
                  THEN
                     pr_dbms_output('i_nv_pair_tab.count = ' ||
                                    i_nv_pair_tab.COUNT);
                  END IF;
               
                  IF l_buf.comment_type IN ('A', 'V')
                  THEN
                     -- ***************************************************************************
                     -- Array SQL handling.
                     -- ***************************************************************************
                  
                     pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                                   ,i_introspect_context     => i_document
                                                                   ,i_aspect_being_monitored => const_intro_array_insertion
                                                                   ,i_mode                   => 'START');
                     l_sql := pkg_pre_etl_tools.fn_get_mapping_col_or_value(i_batch                 => i_batch
                                                                           ,i_document              => i_document
                                                                           ,i_relationship_group_id => l_buf.relationship_group_id
                                                                           ,i_mr_group              => l_buf.mr_group
                                                                           ,i_nv_pair_tab           => i_nv_pair_tab
                                                                           ,i_staged_schema         => i_staged_schema
                                                                           ,i_utility_field_1       => i_utility_field_1
                                                                           ,i_utility_field_2       => i_utility_field_2
                                                                           ,i_utility_field_3       => i_utility_field_3
                                                                           ,i_utility_field_4       => i_utility_field_4
                                                                           ,i_utility_field_5       => i_utility_field_5
                                                                           ,i_introspect_step       => i_introspect_step ||
                                                                                                       ':Array Handling'
                                                                           ,i_debug_mode            => i_debug_mode
                                                                           ,i_json_line             => (CASE
                                                                                                        i_debug_mode
                                                                                                          WHEN
                                                                                                           'TRUE' THEN
                                                                                                           l_buf.json_line
                                                                                                          ELSE
                                                                                                           NULL
                                                                                                       END));
                     pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                                   ,i_introspect_context     => i_document
                                                                   ,i_aspect_being_monitored => const_intro_array_insertion
                                                                   ,i_mode                   => 'END');
                     --
                     IF i_debug_mode = 'TRUE'
                     THEN
                        pr_dbms_output('JSON Array SQL :' || l_sql);
                        pr_dbms_output('Find Swap Use Case : ' ||
                                       i_document);
                     END IF;
                     -- 
                     IF l_buf.comment_type = 'A'
                     THEN
                        -- no need to contextualize the sql here as it gets done in the : fn_sql_to_json_array
                        l_json := fn_pretty_json(fn_sql_to_json_array(i_sql       => fn_rep_ctx_with_lit_from_cache(i_sql => l_sql)
                                                                     ,i_mig_group => i_mig_group)) ||
                                  l_addition;
                     ELSIF l_buf.comment_type = 'V'
                     THEN
                        l_json := fn_sql_to_vanilla_array(i_sql       => fn_contextualize(i_subject => fn_rep_ctx_with_lit_from_cache(i_sql => l_sql)
                                                                                         ,i_context => g_run_context)
                                                         ,i_mig_group => i_mig_group) ||
                                  l_addition;
                     END IF;
                  ELSE
                     -- ***************************************************************************
                     -- Fragment injection SQL handling.
                     -- ***************************************************************************
                     --
                     /*                     IF i_fragment_insertion = 'TRUE'
                        AND i = 1
                     THEN
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('First line of fragment can be skipped as already evaluated and piped.');
                        END IF;
                     ELSE*/
                     --   
                     l_evaluate := pkg_pre_etl_tools.fn_get_mapping_col_or_value(i_batch                 => i_batch
                                                                                ,i_document              => i_document
                                                                                ,i_relationship_group_id => l_buf.relationship_group_id
                                                                                ,i_mr_group              => l_buf.mr_group
                                                                                ,i_nv_pair_tab           => i_nv_pair_tab
                                                                                ,i_staged_schema         => i_staged_schema
                                                                                ,i_utility_field_1       => i_utility_field_1
                                                                                ,i_utility_field_2       => i_utility_field_2
                                                                                ,i_utility_field_3       => i_utility_field_3
                                                                                ,i_utility_field_4       => i_utility_field_4
                                                                                ,i_utility_field_5       => i_utility_field_5
                                                                                ,i_introspect_step       => i_introspect_step ||
                                                                                                            ':Fragment Insertion'
                                                                                ,i_debug_mode            => 'FALSE' /* Always false for evaluate, otherwise the attribute name gets put into the evaluation which stops the hardwired check. */
                                                                                ,i_json_line             => NULL);
                     --                                                                                                            
                     -- Check for hardwired evaluations (save ourselves a needless dynamic exec + context switch.                                                                                                                                                                                                       
                     IF l_evaluate = '''TRUE'''
                     THEN
                        l_evaluate_char_true_false := 'TRUE';
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('Hardwired evaluation as :' ||
                                          TRIM(l_evaluate_char_true_false));
                        END IF;
                     ELSIF l_evaluate = '''FALSE'''
                     THEN
                        l_evaluate_char_true_false := 'FALSE';
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('Hardwired evaluation as :' ||
                                          TRIM(l_evaluate_char_true_false));
                        END IF;
                     ELSE
                        -- Assemble some dynamic SQL to test the evaluation.
                        l_dynamic_select := 'SELECT /*+no_parallel */ (' ||
                                            l_evaluate ||
                                            ') FROM DUAL';
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output(l_dynamic_select);
                        END IF;
                        --
                        pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                                      ,i_introspect_context     => i_document
                                                                      ,i_aspect_being_monitored => const_intro_fragment_eval
                                                                      ,i_mode                   => 'START');
                        EXECUTE IMMEDIATE fn_contextualize(i_subject => l_dynamic_select
                                                          ,i_context => g_run_context)
                           INTO l_evaluate_char_true_false;
                        pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                                      ,i_introspect_context     => i_document
                                                                      ,i_aspect_being_monitored => const_intro_fragment_eval
                                                                      ,i_mode                   => 'END');
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           -- Note the truncate... we must always TRIM on testing of : l_evaluate_char_true_false
                           pr_dbms_output('Evaluation of SQL :' ||
                                          TRIM(l_evaluate_char_true_false) ||
                                          '<-END OF EVAL');
                        END IF;
                     END IF;
                     --
                     IF TRIM(nvl(l_evaluate_char_true_false, 'FALSE')) =
                        'TRUE'
                     THEN
                        -- For Fragments we only put out the start of the fragment from the "Stored Document" when we
                        -- know we need to (because the evaluation is = 'TRUE')
                        pr_pipe_row(fn_smart_cache(i_row                 => t_docbyexample_row(l_buf.json_line
                                                                                              ,'Y'
                                                                                              ,l_buf.mr_group
                                                                                              ,l_buf.relationship_group_id
                                                                                              ,'NULL')
                                                  ,i_smart_cache_index   => i_smart_cache_index
                                                  ,i_use_smart_cache     => i_use_smart_cache
                                                  ,i_smart_cache_usecase => i_smart_cache_usecase
                                                  ,i_origin              => l_origin));
                     
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           -- Note the truncate... we must always TRIM on testing of : l_evaluate_char_true_false
                           pr_dbms_output('Calling fn_related_frag using :' ||
                                          l_buf.mr_group || ',' ||
                                          i_document || ',' ||
                                          l_buf.line_number);
                        END IF;
                        --                        
                        DECLARE
                           l_fragment_doc VARCHAR2(250) := nvl(fn_related_frag(i_mr_group      => l_buf.mr_group
                                                                              ,i_document_name => i_document
                                                                              ,i_line_number   => l_buf.line_number)
                                                              ,i_document);
                        BEGIN
                           --
                           IF i_debug_mode = 'TRUE'
                           THEN
                              -- Note the truncate... we must always TRIM on testing of : l_evaluate_char_true_false
                              pr_dbms_output('Response from fn_related_frag :' ||
                                             l_fragment_doc);
                           END IF;
                           --                             
                           --
                           -- We don't validate the JSON (see i_validate_json) because fragments on their own might not be valid.
                           l_json := NULL;
                           l_json := fn_make_json(i_batch              => i_batch
                                                 ,i_document           => l_fragment_doc
                                                 ,i_mr_group           => l_buf.mr_group
                                                 ,i_mig_group          => i_mig_group
                                                 ,i_nv_pair_tab        => i_nv_pair_tab
                                                 ,i_staged_schema      => i_staged_schema
                                                 ,i_utility_field_1    => i_utility_field_1
                                                 ,i_utility_field_2    => i_utility_field_2
                                                 ,i_utility_field_3    => i_utility_field_3
                                                 ,i_utility_field_4    => i_utility_field_4
                                                 ,i_utility_field_5    => i_utility_field_5
                                                 ,i_introspect_step    => i_introspect_step ||
                                                                          ':Fragment Insertion'
                                                 ,i_validate_json      => 'FALSE'
                                                 ,i_fragment_insertion => 'TRUE'
                                                 ,i_origin             => l_origin
                                                 ,i_debug_mode         => i_debug_mode);
                        EXCEPTION
                           WHEN OTHERS THEN
                              pr_dbms_output('================================================================================');
                              pr_dbms_output('FAILED MAKING FRAGMENT :' ||
                                             l_fragment_doc);
                              pr_dbms_output(SQLERRM);
                              pr_dbms_output('================================================================================');
                              pr_dbms_output('See the SQL statements above in the debug output, especially if you are');
                              pr_dbms_output('experiencing an unmatched bracket in regular expression');
                              pr_dbms_output('================================================================================');
                              --                        
                              RAISE;
                        END;
                        --
                        -- We need to wrap the fragment to create the lines for the pipe outs
                        -- because its not valid JSON otherwise.
                        --
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('Constructed JSON :' ||
                                          l_json);
                        END IF;
                        l_json := '{' ||
                                  REPLACE(l_json, chr(10), NULL) || '}';
                        l_json := pkg_pre_etl_tools.fn_pretty_json(i_json_text => l_json);
                        --
                        l_depth := instr(l_json, chr(10));
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('Depth :' || l_depth);
                        END IF;
                        --
                        l_json := substr(l_json, l_depth + 1);
                        l_json := rtrim(substr(l_json
                                              ,1
                                              ,length(l_json) -
                                               l_depth + 1)
                                       ,chr(10)) || l_addition;
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('JSON to be processed into rows :' ||
                                          nvl(l_json
                                             ,'oops its null... hmm'));
                        END IF;
                        --  
                     ELSE
                        -- Special tag that we will later replace with nothing.
                        l_json := '"FACTOREDOUT":{}' || l_addition;
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output('FACTOREDOUT tag written.');
                        END IF;
                     END IF;
                     -- END IF;
                  END IF;
                  --
                  -- Cache the result incase its used again in another use of the piplined function.
                  -- This is quite likely as we run 3 loops over the JSON.
                  g_cache_json_fragments(l_cache_fragment_idx) := l_json;
                  --
                  IF i_debug_mode = 'TRUE'
                  THEN
                     pr_dbms_output('Injected (either as result of array or fragment insertion) :');
                  END IF;
               END IF;
               --
               -- Pipe out the JSON of the SQL Array result or the injected fragment.
               IF l_json IS NOT NULL
               THEN
                  DECLARE
                     l_pos    PLS_INTEGER := 0;
                     l_sta    PLS_INTEGER := 1;
                     l_cnt    PLS_INTEGER := 1;
                     l_output VARCHAR2(32000);
                  BEGIN
                     l_json := rtrim(l_json, chr(10));
                     WHILE TRUE
                     LOOP
                        l_pos := nvl(instr(l_json, chr(10), 1, l_cnt)
                                    ,0);
                        --
                        IF l_cnt > 1000
                        THEN
                           raise_application_error(-20000
                                                  ,'Possible infinite loop : Emergency Exit');
                        END IF;
                        --
                        IF l_pos = 0
                        THEN
                           l_output := substr(l_json, l_sta);
                        ELSE
                           l_output := substr(l_json
                                             ,l_sta
                                             ,l_pos - l_sta);
                        END IF;
                        --
                        IF i_debug_mode = 'TRUE'
                        THEN
                           pr_dbms_output(l_output);
                        END IF;
                        --
                        pr_pipe_row(fn_smart_cache(i_row                 => t_docbyexample_row(lpad(' '
                                                                                                   ,l_pad_length
                                                                                                   ,' ') ||
                                                                                               l_output
                                                                                              ,'Y'
                                                                                              ,'DEFAULT'
                                                                                              ,NULL
                                                                                              ,'NULL')
                                                  ,i_smart_cache_index   => i_smart_cache_index
                                                  ,i_use_smart_cache     => i_use_smart_cache
                                                  ,i_smart_cache_usecase => i_smart_cache_usecase
                                                  ,i_origin              => l_origin));
                        --
                        IF l_pos = 0
                        THEN
                           EXIT;
                        END IF;
                        l_cnt := l_cnt + 1;
                        l_sta := l_pos + 1;
                     END LOOP;
                  END;
               END IF;
            END IF;
            --
            IF NOT l_skip_lines_bool
            THEN
               IF i_debug_mode = 'TRUE'
               THEN
                  pr_dbms_output('NOT skipped line :' ||
                                 l_buf.line_number || ' / ' ||
                                 l_buf.json_line || ' is verbatim ' ||
                                 l_buf.last_line_verbatim_yn);
               END IF;
               --
               IF nvl(i_skip_mapping, 'FALSE') = 'TRUE'
               THEN
                  l_mapping := NULL;
               ELSE
                  IF l_buf.relationship_group_id IS NULL
                     AND l_buf.mr_group IS NULL
                  THEN
                     l_mapping := 'NULL';
                  ELSE
                     l_mapping := pkg_pre_etl_tools.fn_get_mapping_col_or_value(i_batch                 => i_batch
                                                                               ,i_document              => i_document
                                                                               ,i_relationship_group_id => l_buf.relationship_group_id
                                                                               ,i_mr_group              => l_buf.mr_group
                                                                               ,i_nv_pair_tab           => i_nv_pair_tab
                                                                               ,i_staged_schema         => i_staged_schema
                                                                               ,i_utility_field_1       => i_utility_field_1
                                                                               ,i_utility_field_2       => i_utility_field_2
                                                                               ,i_utility_field_3       => i_utility_field_3
                                                                               ,i_utility_field_4       => i_utility_field_4
                                                                               ,i_utility_field_5       => i_utility_field_5
                                                                               ,i_introspect_step       => NULL /* we call this a lot so don't introspect this */
                                                                               ,i_debug_mode            => i_debug_mode
                                                                               ,i_json_line             => (CASE
                                                                                                            nvl(i_debug_mode
                                                                                                                ,'FALSE')
                                                                                                              WHEN
                                                                                                               'TRUE' THEN
                                                                                                               l_buf.json_line
                                                                                                              ELSE
                                                                                                               NULL
                                                                                                           END));
                  END IF;
               END IF;
               --
               pr_pipe_row(fn_smart_cache(i_row                 => t_docbyexample_row(l_buf.json_line
                                                                                     ,l_buf.last_line_verbatim_yn
                                                                                     ,l_buf.mr_group
                                                                                     ,l_buf.relationship_group_id
                                                                                     ,l_mapping)
                                         ,i_smart_cache_index   => i_smart_cache_index
                                         ,i_use_smart_cache     => i_use_smart_cache
                                         ,i_smart_cache_usecase => i_smart_cache_usecase
                                         ,i_origin              => l_origin));
            
            END IF;
            --
            IF l_skip_lines_bool
               AND l_buf.json_line LIKE l_end_like
            THEN
               IF i_debug_mode = 'TRUE'
               THEN
                  pr_dbms_output('Skip Line Switched off at :' ||
                                 l_buf.line_number);
               END IF;
               l_skip_lines_bool := FALSE;
            END IF;
         END IF;
      END LOOP;
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => l_introspection
                                                    ,i_mode                   => 'END');
      RETURN l_docbyexample_tab;
   EXCEPTION
      WHEN OTHERS THEN
         IF i_debug_mode = 'TRUE'
         THEN
            pr_dbms_output('pkg_pre_etl_tools.fn_tab_func_doc_by_example : ' ||
                           SQLERRM);
         END IF;
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools.fn_tab_func_doc_by_example : ' ||
                                 chr(10) ||
                                 rpad('ERROR STACK ', 80, '*') ||
                                 chr(10) ||
                                 dbms_utility.format_error_stack() ||
                                 chr(10) ||
                                 rpad('BACKTRACE ', 80, '*') ||
                                 chr(10) ||
                                 dbms_utility.format_error_backtrace());
      
   END fn_tab_func_doc_by_example;

   ----------------------------------------------------------------------------
   /* FWD DECLARATION for procedure used in fn_make_json */
   PROCEDURE pr_populate_pem_cache(i_introspect_step IN VARCHAR2 DEFAULT NULL);
   PROCEDURE pr_populate_ctx_value_cache(i_introspect_step IN VARCHAR2 DEFAULT NULL);
   ----------------------------------------------------------------------------

   FUNCTION fn_make_json
   (
      i_batch              IN NUMBER
     ,i_document           IN VARCHAR2
     ,i_mr_group           IN VARCHAR2
     ,i_mig_group          IN VARCHAR2
     ,i_nv_pair_tab        IN t_nv_pair_tab
     ,i_staged_schema      IN VARCHAR2
     ,i_cache_key          IN VARCHAR2 DEFAULT NULL
     ,i_smart_cache_key    IN VARCHAR2 DEFAULT NULL
     ,i_smart_cache_attrs  IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_1    IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_2    IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_3    IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_4    IN VARCHAR2 DEFAULT NULL
     ,i_utility_field_5    IN VARCHAR2 DEFAULT NULL
     ,i_introspect_step    IN VARCHAR2 DEFAULT NULL
     ,i_validate_json      IN VARCHAR2 DEFAULT 'TRUE'
     ,i_fragment_insertion IN VARCHAR2 DEFAULT 'FALSE'
     ,i_origin             IN NUMBER DEFAULT NULL
     ,i_debug_mode         IN VARCHAR2 DEFAULT 'FALSE'
   ) RETURN VARCHAR2 IS
      -- fn_make_json is called for EVERY row processed from the results
      -- driving the insertion into the target table.
      l_blank_nv_pair_tab  t_nv_pair_tab := t_nv_pair_tab();
      l_extended_info_clob CLOB;
      l_return             VARCHAR2(32767);
      l_return2            VARCHAR2(32767);
      l_dynamic_select     VARCHAR2(32767);
      -- l_with               VARCHAR2(32767);
      l_idx             VARCHAR2(500);
      l_type            VARCHAR2(30);
      l_count           PLS_INTEGER := 0;
      l_rows            NUMBER;
      l_dbms_sql_cursor INTEGER;
      --
      l_smart_cache_index VARCHAR2(200);
      l_use_smart_cache   VARCHAR2(5); -- varchar2 TRUE or FALSE.
      --
      l_tab_values t_json_replace_tab := t_json_replace_tab();
      --
      --
      const_intro_func_call        CONSTANT VARCHAR2(30) := 'fn_make_json end to end'; /* Monitor the end to end performance of this function. */
      const_intro_assem_dyn_select CONSTANT VARCHAR2(30) := 'assemble dynamic select'; /* Monitor the assembly of the dynamic select. */
      const_intro_open_parse       CONSTANT VARCHAR2(30) := 'open and parse dynamic'; /* Monitor the opening and parsing of the dynamic select. */
      const_intro_def_columns      CONSTANT VARCHAR2(30) := 'define cols for dynamic'; /* Monitor the column definitions of the dynamic select. */
      const_intro_execute_dynamic  CONSTANT VARCHAR2(30) := 'execute dynamic select'; /* Monitor the execution of the dynamic select (includes execute / fetch / close). */
      const_intro_assem_json       CONSTANT VARCHAR2(30) := 'assemble json'; /* Monitor the assembly of the json. */
      const_intro_flatten_json     CONSTANT VARCHAR2(30) := 'flatten json'; /* Monitor the flattening of the json. */
      --
      l_docbyexample_tab t_docbyexample_tab;
      i_buf              t_docbyexample_row;
      --
      FUNCTION fn_remove_fo
      (
         i_string IN VARCHAR2
        ,i_find   IN VARCHAR2
      ) RETURN VARCHAR2 IS
      BEGIN
         -- If "FACTOREDOUT" is mentioned then apply the regexp replace.
         IF i_string LIKE '%"FACTOREDOUT"%'
         THEN
            RETURN regexp_replace(i_string, i_find, '');
         ELSE
            RETURN i_string;
         END IF;
      END fn_remove_fo;
      --
      FUNCTION fn_run_as_autonomous_transaction(i_dbms_sql_cursor IN INTEGER)
         RETURN NUMBER IS
         PRAGMA AUTONOMOUS_TRANSACTION;
      BEGIN
         l_rows := dbms_sql.execute(i_dbms_sql_cursor);
         COMMIT;
         RETURN l_rows;
      END fn_run_as_autonomous_transaction;
   BEGIN
      g_output.delete;
      g_run_context := fn_get_context_value(i_attr => migration_run_framework.fn_ctx_run_context);
      --
      IF i_debug_mode NOT IN ('TRUE', 'FALSE')
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools.fn_make_json : i_debug_mode must be a character value of TRUE or FALSE.');
      END IF;
   
      -- Note that the cache key is joined to the document name.
      -- If we ever have to handle more than one type of JSON doc per row we'll
      -- need that distinction.
      IF i_cache_key IS NOT NULL
         AND g_tab_json_perf_cache.EXISTS(i_cache_key || '.' ||
                                          i_document)
      THEN
         IF i_debug_mode = 'TRUE'
         THEN
            pr_dbms_output('Responding with cached value for key :' ||
                           i_cache_key || '.' || i_document);
         END IF;
         --
         RETURN g_tab_json_perf_cache(i_cache_key || '.' ||
                                      i_document);
      END IF;
      -- 
      -- SMART CACHE MUST BE AFTER the normal cache (above).
      -- SMART CACHE is a hybrid cache where MOST of the response that will is returned 
      --             comes from cached values but some element attributes will be computed.
      --
      -- In other words we cache the pipelined responses from the fn_tab_func_doc_by_example
      -- function EXCEPT for those that are excluded from the cache.  Those that are excluded
      -- from the cache will regenerate their pipelined response.
      --
      --             It only makes sense to use SMART CACHE if :-
      --
      --             o  The ON_ETL_DRIVER is used.
      --
      --             o  The ON_ETL_DRIVER joins to the same rowid in the source table
      --                multiple times.
      --
      --             o  The ON_ETL_DRIVER utility fields are used, and they 
      --                have different values for each re-use of the rowid for the
      --                source table.
      --
      IF i_smart_cache_key IS NOT NULL
      THEN
         l_smart_cache_index := i_smart_cache_key || '.' ||
                                i_document;
         -- If the use case for 1 exists then all 3 will exist.
         IF g_tab_json_smart_cache.EXISTS(l_smart_cache_index)
         THEN
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('Setting use smart cache to TRUE');
            END IF;
            l_use_smart_cache := 'TRUE';
         ELSE
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('Setting use smart cache to FALSE');
            END IF;
            l_use_smart_cache := 'FALSE';
         END IF;
      ELSE
         l_use_smart_cache := 'FALSE';
      END IF;
      --
      -- NOTE : Its important we don't start introspection BEFORE the cache response 
      -- (that will make our figures wrong - it would make them seem better because cache responses
      --  are going to be a lot quicker than built responses). (from the g_tab_json_perf_cache).
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_func_call
                                                    ,i_mode                   => 'START');
      --
      -- ALL CLEARS BELOW MUST STAY HERE AT THE BEGINNING OF THE JSON CONSTRUCTION.
      -- The global cache of ARRAY SQL frgament insertion MUST be deleted for EACH use of : fn_make_json
      -- DO NOT REMOVE THIS.
      -- The intra clear is used to remove elements that might not contain any content (arrays for example)
      -- DO NOT REMOVE THIS.
      IF i_fragment_insertion = 'FALSE'
      THEN
         pr_clear_fragment_cache;
         pr_clear_intra_clear;
         pr_clear_sql_array_debug;
         pr_clear_nv_pos_cache(i_nv_pair_tab => i_nv_pair_tab);
      END IF;
      --
      pr_populate_pem_cache(i_introspect_step => i_introspect_step);
      pr_populate_find_swap_cache(i_introspect_step => i_introspect_step);
      pr_populate_ctx_value_cache(i_introspect_step => i_introspect_step);
      --
      --
      g_row_count := g_row_count + 1;
      -- Assemble a dynamic select from dual for the necessary values.
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_assem_dyn_select
                                                    ,i_mode                   => 'START');
   
      l_docbyexample_tab := pkg_pre_etl_tools.fn_tab_func_doc_by_example(i_batch               => i_batch
                                                                        ,i_document            => i_document
                                                                        ,i_mr_group            => i_mr_group
                                                                        ,i_mig_group           => i_mig_group
                                                                        ,i_nv_pair_tab         => i_nv_pair_tab
                                                                        ,i_replace_values_tab  => NULL
                                                                        ,i_staged_schema       => i_staged_schema
                                                                        ,i_skip_mapping        => 'FALSE'
                                                                        ,i_use_smart_cache     => l_use_smart_cache
                                                                        ,i_smart_cache_index   => l_smart_cache_index
                                                                        ,i_smart_cache_attrs   => i_smart_cache_attrs
                                                                        ,i_smart_cache_usecase => g_const_usecase_dynamic_select /* 1 */
                                                                        ,i_fragment_insertion  => i_fragment_insertion
                                                                        ,i_origin              => i_origin
                                                                        ,i_utility_field_1     => i_utility_field_1
                                                                        ,i_utility_field_2     => i_utility_field_2
                                                                        ,i_utility_field_3     => i_utility_field_3
                                                                        ,i_utility_field_4     => i_utility_field_4
                                                                        ,i_utility_field_5     => i_utility_field_5
                                                                        ,i_introspect_step     => i_introspect_step
                                                                        ,i_debug_mode          => i_debug_mode);
      FOR i IN l_docbyexample_tab.FIRST .. l_docbyexample_tab.LAST
      LOOP
         i_buf := l_docbyexample_tab(i);
         --
         IF i_buf.verbatim_yn = 'Y'
         THEN
            NULL;
         ELSE
            IF l_count = 0
            THEN
               l_dynamic_select := 'SELECT /*+no_parallel */ ' ||
                                   i_buf.mapping || ',';
            ELSE
               l_dynamic_select := l_dynamic_select || i_buf.mapping || ',';
            END IF;
            --
            l_tab_values.extend(1);
            /* NOTE : The max length of the json value is currently hardwired to 2000.
                      Ideally this should be defined in the mapping tool.
                      The correct table to hold this value would be : PRE_ETL_RELATED_JSON_LINES.
            */
            l_tab_values(l_count + 1) := NEW
                                         t_json_replace_row(field_type   => NULL
                                                           ,char_value   => NULL
                                                           ,char_length  => 2000
                                                           ,number_value => NULL);
            --
            l_count := l_count + 1;
         END IF;
      END LOOP;
      --
      IF l_dynamic_select IS NOT NULL
      THEN
         l_dynamic_select := rtrim(l_dynamic_select, ',');
         l_dynamic_select := l_dynamic_select || ' FROM DUAL';
         --
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_assem_dyn_select
                                                       ,i_mode                   => 'END');
         --
         l_dynamic_select := fn_contextualize(i_subject => l_dynamic_select
                                             ,i_context => g_run_context);
         --
         IF i_debug_mode = 'TRUE'
         THEN
            pr_dbms_output('****************************' || chr(10) ||
                           'Built Dynamic Select :' || chr(10) ||
                           '****************************' || chr(10) ||
                           l_dynamic_select);
         END IF;
         --
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_open_parse
                                                       ,i_mode                   => 'START');
      
         l_dbms_sql_cursor := dbms_sql.open_cursor;
         l_dynamic_select  := fn_rep_ctx_with_lit_from_cache(i_sql => l_dynamic_select);
         IF i_debug_mode = 'TRUE'
         THEN
            pr_dbms_output('******************************' ||
                           chr(10) ||
                           'Replaced Ctx Dynamic Select  :' ||
                           chr(10) ||
                           '******************************' ||
                           chr(10) || l_dynamic_select);
         END IF;
         dbms_sql.parse(l_dbms_sql_cursor
                       ,l_dynamic_select
                       ,dbms_sql.native);
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_open_parse
                                                       ,i_mode                   => 'END');
      
         --
         -- Define the columns for the dynamic query.
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_def_columns
                                                       ,i_mode                   => 'START');
      
         l_count := 1;
      
         l_docbyexample_tab := pkg_pre_etl_tools.fn_tab_func_doc_by_example(i_batch               => i_batch
                                                                           ,i_document            => i_document
                                                                           ,i_mr_group            => i_mr_group
                                                                           ,i_mig_group           => i_mig_group
                                                                           ,i_nv_pair_tab         => l_blank_nv_pair_tab
                                                                           ,i_replace_values_tab  => NULL
                                                                           ,i_staged_schema       => i_staged_schema
                                                                           ,i_skip_mapping        => 'TRUE'
                                                                           ,i_use_smart_cache     => l_use_smart_cache
                                                                           ,i_smart_cache_index   => l_smart_cache_index
                                                                           ,i_smart_cache_attrs   => i_smart_cache_attrs
                                                                           ,i_smart_cache_usecase => g_const_usecase_define_cols /* 2 */
                                                                           ,i_fragment_insertion  => i_fragment_insertion
                                                                           ,i_origin              => i_origin
                                                                           ,i_utility_field_1     => i_utility_field_1
                                                                           ,i_utility_field_2     => i_utility_field_2
                                                                           ,i_utility_field_3     => i_utility_field_3
                                                                           ,i_utility_field_4     => i_utility_field_4
                                                                           ,i_utility_field_5     => i_utility_field_5
                                                                           ,i_introspect_step     => i_introspect_step
                                                                           ,i_debug_mode          => i_debug_mode);
         FOR i IN l_docbyexample_tab.FIRST .. l_docbyexample_tab.LAST
         LOOP
            i_buf := l_docbyexample_tab(i);
            --
            IF i_buf.verbatim_yn != 'Y'
            THEN
               l_type := nvl(fn_get_value_type(i_json_line => i_buf.json_line)
                            ,'SCHEMA ELEMENT');
               IF l_type = 'CHAR'
                  OR l_type = 'BOOLEAN'
               THEN
                  l_tab_values(l_count).field_type := l_type;
                  dbms_sql.define_column_char(l_dbms_sql_cursor
                                             ,l_count
                                             ,l_tab_values     (l_count)
                                              .char_value
                                             ,l_tab_values     (l_count)
                                              .char_length);
               ELSIF l_type = 'NUMBER'
               THEN
                  l_tab_values(l_count).field_type := 'NUMBER';
                  dbms_sql.define_column(l_dbms_sql_cursor
                                        ,l_count
                                        ,l_tab_values(l_count)
                                         .number_value);
               ELSE
                  l_tab_values(l_count).field_type := 'SCHEMA ELEMENT';
                  dbms_sql.define_column_char(l_dbms_sql_cursor
                                             ,l_count
                                             ,l_tab_values     (l_count)
                                              .char_value
                                             ,l_tab_values     (l_count)
                                              .char_length);
               END IF;
               --
               --
               IF i_debug_mode = 'TRUE'
               THEN
                  pr_dbms_output(i_document || '->' ||
                                 to_char(l_count) || ' : ' || l_tab_values(l_count)
                                 .field_type || ' : ' || l_tab_values(l_count)
                                 .char_value || ' : ' || l_tab_values(l_count)
                                 .char_length || ' : ' || l_tab_values(l_count)
                                 .number_value || '<EOL');
               END IF;
               --
               l_count := l_count + 1;
            END IF;
         END LOOP;
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_def_columns
                                                       ,i_mode                   => 'END');
         --
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_execute_dynamic
                                                       ,i_mode                   => 'START');
         --
         l_rows := fn_run_as_autonomous_transaction(i_dbms_sql_cursor => l_dbms_sql_cursor);
         --
         -- Fetches just the one row from dual...
         l_rows := dbms_sql.fetch_rows(l_dbms_sql_cursor);
         --
         FOR i IN l_tab_values.FIRST .. l_tab_values.LAST
         LOOP
            IF l_tab_values(i)
             .field_type = 'CHAR'
                OR l_tab_values(i).field_type = 'BOOLEAN'
            THEN
               dbms_sql.column_value_char(l_dbms_sql_cursor
                                         ,i
                                         ,l_tab_values(i).char_value);
            ELSIF l_tab_values(i).field_type = 'NUMBER'
            THEN
               dbms_sql.column_value(l_dbms_sql_cursor
                                    ,i
                                    ,l_tab_values(i).number_value);
            ELSIF l_tab_values(i).field_type = 'SCHEMA ELEMENT'
            THEN
               dbms_sql.column_value_char(l_dbms_sql_cursor
                                         ,i
                                         ,l_tab_values(i).char_value);
            END IF;
         
         END LOOP;
         --
         IF i_debug_mode = 'TRUE'
         THEN
            pr_dbms_output('Rows from dual :' || l_rows);
            FOR i IN l_tab_values.FIRST .. l_tab_values.LAST
            LOOP
               pr_dbms_output(l_tab_values(i).char_value || ',' || l_tab_values(i)
                              .number_value);
            END LOOP;
         END IF;
      
         dbms_sql.close_cursor(l_dbms_sql_cursor);
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_execute_dynamic
                                                       ,i_mode                   => 'END');
      ELSE
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => i_document
                                                       ,i_aspect_being_monitored => const_intro_assem_dyn_select
                                                       ,i_mode                   => 'END');
      END IF;
      --
      -- Assemble the JSON document.
      -- l_count := 0;
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_assem_json
                                                    ,i_mode                   => 'START');
   
      l_docbyexample_tab := pkg_pre_etl_tools.fn_tab_func_doc_by_example(i_batch               => i_batch
                                                                        ,i_document            => i_document
                                                                        ,i_mr_group            => i_mr_group
                                                                        ,i_mig_group           => i_mig_group
                                                                        ,i_nv_pair_tab         => l_blank_nv_pair_tab
                                                                        ,i_replace_values_tab  => l_tab_values
                                                                        ,i_staged_schema       => i_staged_schema
                                                                        ,i_skip_mapping        => 'TRUE'
                                                                        ,i_use_smart_cache     => l_use_smart_cache
                                                                        ,i_smart_cache_index   => l_smart_cache_index
                                                                        ,i_smart_cache_attrs   => i_smart_cache_attrs
                                                                        ,i_smart_cache_usecase => g_const_usecase_replace_vals /* 3 */
                                                                        ,i_fragment_insertion  => i_fragment_insertion
                                                                        ,i_origin              => i_origin
                                                                        ,i_utility_field_1     => i_utility_field_1
                                                                        ,i_utility_field_2     => i_utility_field_2
                                                                        ,i_utility_field_3     => i_utility_field_3
                                                                        ,i_utility_field_4     => i_utility_field_4
                                                                        ,i_utility_field_5     => i_utility_field_5
                                                                        ,i_introspect_step     => i_introspect_step
                                                                        ,i_debug_mode          => i_debug_mode);
      FOR i IN l_docbyexample_tab.FIRST .. l_docbyexample_tab.LAST
      LOOP
         i_buf := l_docbyexample_tab(i);
         --
         l_return := l_return || i_buf.json_line;
      END LOOP;
      --
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_assem_json
                                                    ,i_mode                   => 'END');
   
      --
      --
      l_return := fn_remove_fo(l_return, ',\s*"FACTOREDOUT":{}'); /* Kate would like the naming here... :) */
      IF i_debug_mode = 'TRUE'
      THEN
         pr_dbms_output('Regexp the FACTOREDOUT tag.');
      END IF;
      --
      -- We need to account for the possibility that the returning json has had lines removed
      -- at the end... which could leave a hanging ,} or ,] (either of those would need to be cleaned out.
      IF substr(l_return, -3, 3) = ',}]'
      THEN
         l_return := rtrim(l_return, ',}]') || '}]';
      END IF;
      IF substr(l_return, -2, 2) = ',}'
      THEN
         l_return := rtrim(l_return, ',}') || '}';
      END IF;
   
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_flatten_json
                                                    ,i_mode                   => 'START');
      --
      -- Flatten (and compactify's) the JSON - this also has the nice side benefit
      -- of actually validating the result too.
      -- Intra clear gets rid of any JSON element fragments that are empty.
      -- Intra clear is populated when we know we're dealing with elements that might
      -- end up not having any content.  Its possible that intra clear could make the JSON
      -- invalid (if used incorrectly).
      IF i_validate_json = 'TRUE'
      THEN
         IF i_fragment_insertion = 'FALSE'
            AND fn_get_document_type(i_document_name => i_document) =
            'STORED FRAGMENT'
         THEN
            -- Its possible a stored fragment could be stored separately (possibly on the same row as the main document)
            -- This removes the subdocument attr name, leaving the bracketed anonymous JSON.
            l_return := TRIM(substr(l_return
                                   ,instr(l_return, ':') + 1));
            IF i_debug_mode = 'TRUE'
            THEN
               pr_dbms_output('FRAGMENT USED as JSON :' || l_return);
            END IF;                                   
         END IF;
         l_return2 := fn_find_and_swap(i_find_swap_string => fn_remove_fo(fn_remove_fo(fn_remove_fo(fn_flattened_json(i_json_text => l_return)
                                                                                                   ,'\s*,"FACTOREDOUT":{}')
                                                                                      ,'\s*"FACTOREDOUT":{},')
                                                                         ,'\s*"FACTOREDOUT":{}')
                                      ,i_mig_group        => i_mig_group);
         l_return2 := fn_intra_clear(i_string => l_return2);
         --
         l_return2 := fn_flattened_json(i_json_text => l_return2); /* final validate after handling any find/swaps. */
         --
         IF l_return2 IS NULL
         THEN
            raise_application_error(-20000
                                   ,'pkg_pre_etl_tools.fn_make_json (2): json is not valid.');
         END IF;
      END IF;
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_flatten_json
                                                    ,i_mode                   => 'END');
   
      --
      --
      IF i_debug_mode = 'TRUE'
      THEN
         pr_dbms_output('JSON made :' || nvl(l_return2, l_return));
      END IF;
      --
      -- Cache handling.
      -- We only keep a small cache of built JSON.  Its only really for intra row
      -- handling.  Because the JSON is expensive to assemble we don't want to reassemble
      -- the JSON when we're within the same single row.
      IF i_cache_key IS NOT NULL
      THEN
         g_tab_json_perf_cache(i_cache_key || '.' || i_document) := nvl(l_return2
                                                                       ,l_return);
         g_json_cache_cycle(g_cache_position) := i_cache_key || '.' ||
                                                 i_document;
         --
         g_cache_position := g_cache_position + 1;
         -- We cycle back around to 1 when the next index we'd use breaks our
         -- threshold.
         IF g_cache_position > g_max_cache
         THEN
            g_cache_position := 1;
         END IF;
         -- Clear 1 position ahead of the current cached value.
         -- This performs a FILO stack..
         IF g_json_cache_cycle.EXISTS(g_cache_position)
         THEN
            IF g_tab_json_perf_cache.EXISTS(g_json_cache_cycle(g_cache_position))
            THEN
               g_tab_json_perf_cache.delete(g_json_cache_cycle(g_cache_position));
            END IF;
         END IF;
      END IF;
   
      --
      -- Smart Cache handling.
      -- Smart Caches are really for inter row (over more than 1 row) handling. 
      -- But again we don't want to keep a massive cache...  
      IF i_smart_cache_key IS NOT NULL
         AND l_use_smart_cache = 'FALSE'
      THEN
         g_json_smart_cache_cycle(g_smart_cache_position) := l_smart_cache_index;
         --
         g_smart_cache_position := g_smart_cache_position + 1;
         -- We cycle back around to 1 when the next index we'd use breaks our
         -- threshold.
         IF g_smart_cache_position > g_max_smart_cache
         THEN
            g_smart_cache_position := 1;
         END IF;
         -- Clear 1 position ahead of the current cached value.
         -- This performs a FILO stack..
         IF g_json_smart_cache_cycle.EXISTS(g_smart_cache_position)
         THEN
            IF g_tab_json_smart_cache.EXISTS(g_json_smart_cache_cycle(g_smart_cache_position))
            THEN
               g_tab_json_smart_cache.delete(g_json_smart_cache_cycle(g_smart_cache_position));
            END IF;
         END IF;
      END IF;
   
      --
      pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                    ,i_introspect_context     => i_document
                                                    ,i_aspect_being_monitored => const_intro_func_call
                                                    ,i_mode                   => 'END');
   
      --
      IF i_validate_json = 'TRUE'
      THEN
         RETURN fn_find_and_swap(i_find_swap_string => nvl(l_return2
                                                          ,l_return)
                                ,i_mig_group        => i_mig_group);
      ELSE
         RETURN nvl(l_return2, l_return);
      END IF;
   
   EXCEPTION
      WHEN OTHERS THEN
         -- NoFormat Start
         pr_dbms_output(q'[  ______                    _   _                 _    _                 _ _           ]');
         pr_dbms_output(q'[ |  ____|                  | | (_)               | |  | |               | | |          ]');
         pr_dbms_output(q'[ | |__  __  _____ ___ _ __ | |_ _  ___  _ __     | |__| | __ _ _ __   __| | | ___ _ __ ]');
         pr_dbms_output(q'[ |  __| \ \/ / __/ _ \ '_ \| __| |/ _ \| '_ \    |  __  |/ _` | '_ \ / _` | |/ _ \ '__|]');
         pr_dbms_output(q'[ | |____ >  < (_|  __/ |_) | |_| | (_) | | | |   | |  | | (_| | | | | (_| | |  __/ |   ]');
         pr_dbms_output(q'[ |______/_/\_\___\___| .__/ \__|_|\___/|_| |_|   |_|  |_|\__,_|_| |_|\__,_|_|\___|_|   ]');
         pr_dbms_output(q'[                     | |                                                               ]');
         pr_dbms_output(q'[                     |_|                                                               ]');
         -- NoFormat End
         pr_dbms_output(lpad('*', 100, '*'));
         IF SQLERRM LIKE '%ORA-00936%'
         THEN
            pr_dbms_output('FIX SUGGESTION : Your code/comment might reference a ":mapped" field that doesn''t exist, or has changed to multi-mapping. (i.e. :mapped should be :mapped#1 etc...)');
         END IF;
         pr_dbms_output(SQLERRM || fn_lf ||
                        dbms_utility.format_error_backtrace);
         pr_dbms_output(lpad('*', 100, '*') || chr(10));
         --
         IF i_nv_pair_tab.COUNT > 0
         THEN
            FOR i IN 1 .. i_nv_pair_tab.COUNT
            LOOP
               pr_dbms_output_big(i_clob => i_nv_pair_tab(i)
                                            .name || '=' || i_nv_pair_tab(i)
                                            .value || '<EOL');
            END LOOP;
         END IF;
         --
         pr_dbms_output(lpad('*', 100, '*'));
         pr_dbms_output_big(i_clob => '(' || to_char(g_row_count) ||
                                      ') Dynamic SQL was : ' ||
                                      l_dynamic_select);
         pr_dbms_output(lpad('*', 100, '*'));
         pr_dbms_output_big(i_clob => '(' || to_char(g_row_count) ||
                                      ') JSON (l_return) was : ' ||
                                      l_return);
         pr_dbms_output_big(i_clob => '(' || to_char(g_row_count) ||
                                      ') JSON (l_return2) was : ' ||
                                      l_return2);
         --
         pr_dbms_output(lpad('*', 100, '*'));
         pr_dbms_output('SQL Array queries that were run during this fn_make_json call...');
         IF g_sql_array_debug.COUNT > 0
         THEN
            FOR i IN g_sql_array_debug.FIRST .. g_sql_array_debug.LAST
            LOOP
               pr_dbms_output('Query (' || to_char(i) || ')');
               pr_dbms_output(g_sql_array_debug(i));
               pr_dbms_output(' ');
               pr_dbms_output(' ');
            END LOOP;
         END IF;
         --         
         pr_dbms_output(lpad('*', 100, '*'));
         pr_dbms_output('Intra Clear Entries Are...');
         IF g_json_intra_clear.COUNT > 0
         THEN
            l_idx := g_json_intra_clear.FIRST;
            WHILE l_idx IS NOT NULL
            LOOP
               pr_dbms_output(l_idx);
               l_idx := g_json_intra_clear.next(l_idx);
            END LOOP;
         END IF;
      
         --                              
         pr_dbms_output(lpad('*', 100, '*'));
         IF SQLERRM LIKE '%ORA-00936%'
         THEN
            pr_dbms_output('FIX SUGGESTION : Your code/comment might reference a ":mapped" field that doesn''t exist, or has changed to multi-mapping. (i.e. :mapped should be :mapped#1 etc...)');
         END IF;
         pr_dbms_output(SQLERRM || fn_lf ||
                        dbms_utility.format_error_backtrace);
         pr_dbms_output(lpad('*', 100, '*'));
         --
         pr_dbms_output('Params:');
         pr_dbms_output('i_document           :' || i_document);
         pr_dbms_output('i_mr_group           :' || i_mr_group);
         pr_dbms_output('i_staged_schema      :' || i_staged_schema ||
                        ' translated as ' ||
                        fn_contextualize(i_subject => i_staged_schema
                                        ,i_context => fn_get_context_value(i_attr => migration_run_framework.fn_ctx_run_context)));
         pr_dbms_output('i_validate_json      :' || i_validate_json);
         pr_dbms_output('i_fragment_insertion :' ||
                        i_fragment_insertion);
         pr_dbms_output('i_debug_mode         :' || i_debug_mode);
         --
         --
         IF i_debug_mode = 'FALSE'
         THEN
            l_extended_info_clob := NULL;
            IF g_output.COUNT > 0
            THEN
               FOR i IN 1 .. g_output.COUNT
               LOOP
                  l_extended_info_clob := l_extended_info_clob ||
                                          g_output(i);
               END LOOP;
            END IF;
            --
            migration_run_framework.pr_log(i_log_type          => migration_run_framework.fn_error
                                          ,i_log_entry         => 'Failed In fn_make_json.'
                                          ,i_log_batch         => i_batch
                                          ,i_log_extended_info => l_extended_info_clob);
         END IF;
         --         
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools.fn_make_json : ' ||
                                 i_document || ' : Failed : ' ||
                                 SQLERRM);
   END fn_make_json;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_action_comments_hash
   (
      i_using_src_table_name IN VARCHAR2
     ,i_mr_group             IN VARCHAR2
   ) RETURN RAW IS
      l_clob CLOB;
   BEGIN
      -- Gets a hash for all "actionable comments" - thats comments that control
      -- how the data is used in the migration.
      -- This will only be called if the migration does something with JSON.
      FOR i_buf IN (SELECT *
                      FROM (SELECT (SELECT substr(function_value, 2) || ',' ||
                                           lookup_value || ',' ||
                                           array_value
                                      FROM (SELECT pec.mr_group
                                                  ,pec.relationship_group_id
                                                  ,decode(pec.comment_type
                                                         ,'V'
                                                         ,'A'
                                                         ,pec.comment_type) AS comment_type
                                                  ,CAST(pec.comments AS
                                                        VARCHAR2(32000)) AS comments
                                              FROM pre_etl_comments pec
                                             WHERE pec.relationship_group_id =
                                                   pem.relationship_group_id
                                               AND pec.mr_group =
                                                   pem.mr_group
                                               AND pec.comment_type IN
                                                   ('F', 'L', 'A', 'V')
                                               AND decode(decode(pec.comment_type
                                                                ,'V'
                                                                ,'A'
                                                                ,pec.comment_type)
                                                         ,'F'
                                                         ,decode(substr(CAST(pec.comments AS
                                                                             VARCHAR2(32000))
                                                                       ,1
                                                                       ,1)
                                                                ,'='
                                                                ,1
                                                                ,0)
                                                         ,'L'
                                                         ,decode(upper(substr(CAST(pec.comments AS
                                                                                   VARCHAR2(32000))
                                                                             ,1
                                                                             ,6))
                                                                ,'SELECT'
                                                                ,1
                                                                ,decode(upper(substr(CAST(pec.comments AS
                                                                                          VARCHAR2(32000))
                                                                                    ,1
                                                                                    ,4))
                                                                       ,'WITH'
                                                                       ,1
                                                                       ,0))
                                                         ,'A'
                                                         ,decode(upper(substr(CAST(pec.comments AS
                                                                                   VARCHAR2(32000))
                                                                             ,1
                                                                             ,6))
                                                                ,'SELECT'
                                                                ,1
                                                                ,decode(upper(substr(CAST(pec.comments AS
                                                                                          VARCHAR2(32000))
                                                                                    ,1
                                                                                    ,4))
                                                                       ,'WITH'
                                                                       ,1
                                                                       ,0))
                                                         ,0) = 1
                                             ORDER BY pec.mr_group
                                                     ,pec.relationship_group_id)
                                    pivot(MAX(comments)
                                       FOR comment_type IN('F' AS
                                                          function_value
                                                         ,'L' AS
                                                          lookup_value
                                                         ,'A' AS
                                                          array_value))) AS hashable
                              FROM pre_etl_mapped pem
                             WHERE pem.table_name =
                                   upper(i_using_src_table_name)
                               AND pem.mr_group = i_mr_group
                             ORDER BY pem.mr_group
                                     ,pem.relationship_group_id) hashable_set
                     WHERE hashable_set.hashable IS NOT NULL)
      LOOP
         l_clob := l_clob || i_buf.hashable;
      END LOOP;
      --
      RETURN fn_get_hash_for_clob(i_clob => l_clob);
   END fn_get_action_comments_hash;
   ----------------------------------------------------------------------------

   FUNCTION fn_contextualize
   (
      i_subject IN CLOB
     ,i_context IN VARCHAR2
   ) RETURN CLOB IS
      l_return_clob CLOB;
   BEGIN
      IF i_subject LIKE '%${%'
      THEN
         l_return_clob := i_subject;
         FOR i_buf IN (SELECT substitution_key
                             ,substitution_value
                         FROM pre_etl_substitution_values pesv
                        WHERE pesv.context_name = upper(i_context))
         LOOP
            l_return_clob := fn_upper_keyword_clob(i_statement => l_return_clob
                                                  ,i_keyword   => i_buf.substitution_key);
            pr_replace_clob(io_subject => l_return_clob
                           ,i_replace  => upper(i_buf.substitution_key)
                           ,i_value    => i_buf.substitution_value);
            --
            IF l_return_clob NOT LIKE '%${%'
            THEN
               EXIT; -- exit the loop as there is no point in wasting processing if there is no more substitutes.
            END IF;
         END LOOP;
         RETURN l_return_clob;
      ELSE
         RETURN i_subject;
      END IF;
   END fn_contextualize;

   ----------------------------------------------------------------------------

   FUNCTION fn_contextualize
   (
      i_subject IN VARCHAR2
     ,i_context IN VARCHAR2
   ) RETURN VARCHAR2 IS
      l_return_varchar2 VARCHAR2(32767) := i_subject;
   BEGIN
      IF l_return_varchar2 LIKE '%${%'
      THEN
         FOR i_buf IN (SELECT substitution_key
                             ,substitution_value
                         FROM pre_etl_substitution_values pesv
                        WHERE pesv.context_name = upper(i_context))
         LOOP
            l_return_varchar2 := fn_upper_keyword_varchar2(i_statement => l_return_varchar2
                                                          ,i_keyword   => i_buf.substitution_key);
            pr_replace_varchar2(io_subject => l_return_varchar2
                               ,i_replace  => upper(i_buf.substitution_key)
                               ,i_value    => i_buf.substitution_value);
            --
            IF l_return_varchar2 NOT LIKE '%${%'
            THEN
               EXIT; -- exit the loop as there is no point in wasting processing if there is no more substitutes.
            END IF;
         END LOOP;
      END IF;
      RETURN l_return_varchar2;
   END fn_contextualize;

   ----------------------------------------------------------------------------

   FUNCTION fn_forms_contextualize
   (
      i_subject IN VARCHAR2
     ,i_context IN VARCHAR2
   ) RETURN VARCHAR2 IS
      l_clob CLOB := i_subject;
   BEGIN
      RETURN REPLACE(pkg_pre_etl_tools.fn_upper_keyword_clob(i_statement => fn_contextualize(i_subject => l_clob
                                                                                            ,i_context => i_context)
                                                            ,i_keyword   => g_tool_const_batch)
                    ,g_tool_const_batch
                    ,'1000');
   END fn_forms_contextualize;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_instance RETURN VARCHAR2 IS
      l_instance VARCHAR2(200);
   BEGIN
      SELECT instance_name INTO l_instance FROM v$instance;
      RETURN l_instance;
   END fn_get_instance;

   ----------------------------------------------------------------------------

   FUNCTION fn_get_vc2_pec_comments(i_rowid IN ROWID) RETURN VARCHAR2 IS
      l_return VARCHAR2(32000) := NULL;
   BEGIN
      IF i_rowid IS NOT NULL
      THEN
         SELECT pec.comments
           INTO l_return
           FROM pre_etl_comments pec
          WHERE pec.rowid = i_rowid;
      END IF;
      --
      RETURN l_return;
      --
   EXCEPTION
      WHEN no_data_found THEN
         RETURN NULL;
   END fn_get_vc2_pec_comments;

   ----------------------------------------------------------------------------

   FUNCTION fn_has_oed_driver_bool
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN BOOLEAN result_cache IS
      l_dummy VARCHAR2(1);
   BEGIN
      SELECT NULL
        INTO l_dummy
        FROM pre_etl_migration_src pems
       WHERE pems.migration_group = i_migration_group
         AND pems.migration_name = i_migration_name
         AND pems.use_with_on_etl_driver_yn = 'Y';
      RETURN TRUE;
   EXCEPTION
      WHEN no_data_found THEN
         RETURN FALSE;
   END fn_has_oed_driver_bool;

   ----------------------------------------------------------------------------

   FUNCTION fn_touch_possible_yn
   (
      i_context         IN VARCHAR2
     ,i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN VARCHAR2 IS
      CURSOR cur_source
      (
         c_context         IN VARCHAR2
        ,c_migration_group IN VARCHAR2
        ,c_migration_name  IN VARCHAR2
      ) IS
         SELECT CAST(pkg_pre_etl_tools.fn_contextualize(i_subject => pemh.staged_schema
                                                       ,i_context => c_context) AS
                     VARCHAR2(30)) AS owner
           FROM pre_etl_migration_header pemh
          WHERE pemh.migration_group = c_migration_group
            AND pemh.migration_name = c_migration_name;
      cur_source_buf cur_source%ROWTYPE;
      --
      --
      CURSOR cur_touch
      (
         c_owner           IN VARCHAR2
        ,c_migration_group IN VARCHAR2
        ,c_migration_name  IN VARCHAR2
      ) IS
         WITH ms_tabs AS
          (SELECT dtc.table_name
             FROM dba_tab_cols dtc
            WHERE dtc.owner = c_owner
              AND dtc.column_name LIKE 'MIGRATION_STATUS')
         SELECT (CASE
                   WHEN use_with_on_etl_driver_yn = 'N'
                        AND tables_in_source = 1
                        AND EXISTS
                    (SELECT NULL
                           FROM ms_tabs m
                          WHERE m.table_name =
                                (SELECT pems2.table_name
                                   FROM pre_etl_migration_src pems2
                                  WHERE pems2.migration_group =
                                        c_migration_group
                                    AND pems2.migration_name =
                                        c_migration_name)) THEN
                    'Y'
                   WHEN use_with_on_etl_driver_yn = 'Y'
                        AND EXISTS
                    (SELECT NULL
                           FROM ms_tabs m
                          WHERE m.table_name =
                                (SELECT pems2.table_name
                                   FROM pre_etl_migration_src pems2
                                  WHERE pems2.use_with_on_etl_driver_yn = 'Y'
                                    AND pems2.migration_group =
                                        c_migration_group
                                    AND pems2.migration_name =
                                        c_migration_name)) THEN
                    'Y'
                   ELSE
                    'N'
                END) AS touch_possible_yn
           FROM (SELECT (SELECT decode(MAX(pems.table_name)
                                      ,NULL
                                      ,'N'
                                      ,'Y')
                           FROM pre_etl_migration_src pems
                          WHERE pems.use_with_on_etl_driver_yn = 'Y'
                            AND pems.migration_group =
                                c_migration_group
                            AND pems.migration_name = c_migration_name) AS use_with_on_etl_driver_yn
                       ,(SELECT COUNT(*)
                           FROM pre_etl_migration_src pems
                          WHERE pems.migration_group =
                                c_migration_group
                            AND pems.migration_name = c_migration_name
                          GROUP BY pems.migration_group
                                  ,pems.migration_name) AS tables_in_source
                   FROM dual) xx;
      cur_touch_buf cur_touch%ROWTYPE;
   BEGIN
      OPEN cur_source(c_context         => i_context
                     ,c_migration_group => i_migration_group
                     ,c_migration_name  => i_migration_name);
      FETCH cur_source
         INTO cur_source_buf;
      CLOSE cur_source;
      --
      OPEN cur_touch(c_owner           => cur_source_buf.owner
                    ,c_migration_group => i_migration_group
                    ,c_migration_name  => i_migration_name);
      FETCH cur_touch
         INTO cur_touch_buf;
      CLOSE cur_touch;
      --
      RETURN cur_touch_buf.touch_possible_yn;
   END fn_touch_possible_yn;

   ----------------------------------------------------------------------------

   FUNCTION fn_touch_possible_yn_cached
   (
      i_context         IN VARCHAR2
     ,i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
   ) RETURN VARCHAR2 result_cache IS
   BEGIN
      RETURN fn_touch_possible_yn(i_context         => i_context
                                 ,i_migration_group => i_migration_group
                                 ,i_migration_name  => i_migration_name);
   END fn_touch_possible_yn_cached;

   ----------------------------------------------------------------------------

   FUNCTION fn_is_json_change_valid
   (
      i_document_name IN VARCHAR2
     ,i_line_number   IN NUMBER
     ,i_changed_line  IN VARCHAR2
   ) RETURN BOOLEAN IS
      l_json VARCHAR2(32767) := NULL;
      CURSOR cur_pejd(c_document_name IN VARCHAR2) IS
         SELECT pejd.document_type
           FROM pre_etl_json_document pejd
          WHERE pejd.document_name = c_document_name;
      cur_pejd_buf        cur_pejd%ROWTYPE;
      l_add_brackets_bool BOOLEAN := FALSE;
      l_found_bool        BOOLEAN := FALSE;
   BEGIN
      OPEN cur_pejd(c_document_name => i_document_name);
      FETCH cur_pejd
         INTO cur_pejd_buf;
      l_found_bool := cur_pejd%FOUND;
      CLOSE cur_pejd;
      IF NOT l_found_bool
      THEN
         raise_application_error(-20000
                                ,'Unrecognised Document Name.');
      END IF;
      IF cur_pejd_buf.document_type = 'STORED FRAGMENT'
      THEN
         l_add_brackets_bool := TRUE;
      ELSE
         l_add_brackets_bool := FALSE;
      END IF;
      --
      FOR i_buf IN (SELECT (CASE pejl.line_number
                              WHEN i_line_number THEN
                               i_changed_line
                              ELSE
                               pejl.json_line
                           END) AS json_line
                      FROM pre_etl_json_lines pejl
                     WHERE pejl.document_name = i_document_name
                     ORDER BY pejl.line_number)
      LOOP
         l_json := l_json || i_buf.json_line;
      END LOOP;
      IF fn_flattened_json(i_json_text => (CASE
                                           WHEN l_add_brackets_bool THEN
                                            '{'
                                           ELSE
                                            NULL
                                        END) || l_json || (CASE
                                           WHEN l_add_brackets_bool THEN
                                            '}'
                                           ELSE
                                            NULL
                                        END)) IS NULL
      THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END fn_is_json_change_valid;

   ----------------------------------------------------------------------------

   PROCEDURE pr_get_touch
   (
      i_context         IN VARCHAR2
     ,i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
     ,o_touch           OUT VARCHAR2
   ) IS
      CURSOR cur_touch
      (
         c_context         IN VARCHAR2
        ,c_migration_group IN VARCHAR2
        ,c_migration_name  IN VARCHAR2
      ) IS
         SELECT decode(touch_migration_status_yn
                      ,'Y'
                      ,'   WHEN (' || trigger_sql || ') THEN ' ||
                       chr(10) ||
                       '     INTO GTT_TOUCH_MIGRATION_STATUS ' ||
                       chr(10) || '     (rid)' || chr(10) ||
                       '   VALUES' || chr(10) ||
                       '     (mig_driver_staged_rowid)'
                      ,NULL) AS touch
               ,touch_possible_yn
           FROM (SELECT pkg_pre_etl_tools.fn_touch_possible_yn(i_context         => c_context
                                                              ,i_migration_group => c_migration_group
                                                              ,i_migration_name  => c_migration_name) AS touch_possible_yn
                       ,pemd.trigger_sql
                       ,pemd.touch_migration_status_yn
                   FROM dual
                   LEFT JOIN pre_etl_migration_detail pemd
                     ON (pemd.migration_group = c_migration_group AND
                        pemd.migration_name = c_migration_name))
          ORDER BY 2 DESC;
      cur_touch_buf cur_touch%ROWTYPE;
   BEGIN
      FOR cur_touch_buf IN cur_touch(c_context         => i_context
                                    ,c_migration_group => i_migration_group
                                    ,c_migration_name  => i_migration_name)
      LOOP
         IF cur_touch_buf.touch IS NOT NULL
         THEN
            o_touch := o_touch || cur_touch_buf.touch || ' ' ||
                       chr(10);
         END IF;
      END LOOP;
      o_touch := rtrim(o_touch, chr(10));
   END pr_get_touch;

   ----------------------------------------------------------------------------

   PROCEDURE pr_load_json_document
   (
      i_document      IN VARCHAR2
     ,i_document_type IN VARCHAR2
     ,i_clob          IN VARCHAR2
     ,i_replace_bool  IN BOOLEAN DEFAULT FALSE
   ) IS
      l_string      VARCHAR2(2000);
      l_line_number NUMBER;
      TYPE t_rec_lines IS RECORD(
          line_text   VARCHAR2(2000)
         ,line_number NUMBER);
      TYPE t_tab IS TABLE OF t_rec_lines INDEX BY BINARY_INTEGER;
      l_tab t_tab;
      --
      FUNCTION fn_get_leading_tab_count(i_text IN VARCHAR2)
         RETURN NUMBER IS
      BEGIN
         RETURN(length(i_text) - length(ltrim(i_text, chr(9))));
      END fn_get_leading_tab_count;
      --
      PROCEDURE pr_strip_leading_chars
      (
         io_tab  IN OUT t_tab
        ,i_chars IN NUMBER
      ) IS
      BEGIN
         IF i_chars > 0
         THEN
            IF io_tab.COUNT > 0
            THEN
               FOR i IN io_tab.FIRST .. io_tab.LAST
               LOOP
                  FOR i2 IN 1 .. i_chars
                  LOOP
                     IF substr(io_tab(i).line_text, 1, 1) = chr(9)
                     THEN
                        io_tab(i).line_text := substr(io_tab(i)
                                                      .line_text
                                                     ,2);
                     END IF;
                  END LOOP;
               END LOOP;
            END IF;
         END IF;
      END pr_strip_leading_chars;
   BEGIN
      l_line_number := 1;
      FOR i IN 1 .. length(i_clob)
      LOOP
         IF substr(i_clob, i, 1) != fn_lf
         THEN
            l_string := l_string || substr(i_clob, i, 1);
         ELSE
            IF TRIM(l_string) IS NOT NULL
            THEN
               l_tab(l_tab.COUNT + 1).line_number := l_line_number;
               l_tab(l_tab.COUNT).line_text := rtrim(l_string);
               l_line_number := l_line_number + 1;
            END IF;
            l_string := NULL;
         END IF;
      END LOOP;
      -- pr_dbms_output(l_tab.COUNT);
      IF i_replace_bool
      THEN
         DELETE FROM pre_etl_json_lines
          WHERE document_name = i_document;
         DELETE FROM pre_etl_json_document
          WHERE document_name = i_document;
      END IF;
      --
   
      pr_strip_leading_chars(io_tab  => l_tab
                            ,i_chars => fn_get_leading_tab_count(i_text => l_tab(1)
                                                                           .line_text));
      -- Might fail (correctly) if not in replace mode.
      INSERT INTO pre_etl_json_document
         (document_name
         ,comments
         ,document_type)
      VALUES
         (i_document
         ,NULL
         ,i_document_type);
      FORALL i IN 1 .. l_tab.COUNT
         INSERT INTO pre_etl_json_lines
            (id
            ,document_name
            ,line_number
            ,json_line)
         VALUES
            (pre_etl_seq_pejl.nextval
            ,i_document
            ,l_tab(i).line_number
            ,l_tab(i).line_text);
      COMMIT;
   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK;
   END pr_load_json_document;

   ----------------------------------------------------------------------------

   PROCEDURE pr_test_compilation
   (
      i_statement_clob IN CLOB
     ,i_oed_binds_bool IN BOOLEAN
     ,i_context        IN VARCHAR2
     ,o_errors_clob    OUT CLOB
   ) IS
      l_errors_found_bool BOOLEAN := FALSE;
      l_procedure_name    VARCHAR(30) := 'test_comp_' ||
                                         to_char(systimestamp
                                                ,'YYYYMMDDHH24MISSFF6');
      l_statement_clob    CLOB := i_statement_clob;
   BEGIN
      BEGIN
         IF i_oed_binds_bool
         THEN
            l_statement_clob := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_clob(i_statement => l_statement_clob
                                                                               ,i_keyword   => fn_work_partitions)
                                       ,fn_work_partitions
                                       ,'0');
            l_statement_clob := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_clob(i_statement => l_statement_clob
                                                                               ,i_keyword   => fn_thread_number)
                                       ,fn_thread_number
                                       ,'0');
         END IF;
         --
         IF instr(upper(l_statement_clob), g_tool_const_batch) > 0
         THEN
            l_statement_clob := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_clob(i_statement => l_statement_clob
                                                                               ,i_keyword   => g_tool_const_batch)
                                       ,g_tool_const_batch
                                       ,'0');
         END IF;
         --
         EXECUTE IMMEDIATE fn_contextualize(i_subject => 'CREATE OR REPLACE PROCEDURE ' ||
                                                         l_procedure_name ||
                                                         ' IS ' ||
                                                         fn_lf ||
                                                         'BEGIN ' ||
                                                         fn_lf ||
                                                         l_statement_clob ||
                                                         fn_lf ||
                                                         ' END ' ||
                                                         l_procedure_name || ';'
                                           ,i_context => i_context);
      
      EXCEPTION
         WHEN OTHERS THEN
            l_errors_found_bool := FALSE;
            FOR i_buf IN (SELECT (ue.line - 2) AS line
                                ,ue.text error_text
                                ,ds.text code_text
                            FROM user_errors ue
                            JOIN user_source ds
                              ON (ds.name = ue.name AND
                                 ds.type = ue.type AND
                                 ds.line = ue.line)
                           WHERE ue.name = upper(l_procedure_name)
                           ORDER BY sequence DESC)
            LOOP
               l_errors_found_bool := TRUE;
               o_errors_clob       := o_errors_clob ||
                                      rpad(i_buf.line, 8, ' ') ||
                                      i_buf.error_text || fn_lf ||
                                      '        ' || i_buf.code_text ||
                                      fn_lf;
            END LOOP;
            --
            IF NOT l_errors_found_bool
            THEN
               o_errors_clob := o_errors_clob ||
                                'Unexpected Error : ' || SQLERRM ||
                                fn_lf;
            END IF;
            --
            IF instr(o_errors_clob
                    , q'[bad bind variable 'UTILITY_FIELD]') > 0
            THEN
               o_errors_clob := '**********************************************************************************************************' ||
                                fn_lf ||
                                'Use of UTILITY FIELDS is only possible on migrations that use the migration driver tables (ON_ETL_DRIVER).' ||
                                fn_lf ||
                                '**********************************************************************************************************' ||
                                fn_lf || o_errors_clob;
            END IF;
            o_errors_clob := o_errors_clob || fn_lf;
            o_errors_clob := o_errors_clob || 'Migration Statement' ||
                             fn_lf;
            o_errors_clob := o_errors_clob || '===================' ||
                             fn_lf;
            o_errors_clob := o_errors_clob || i_statement_clob;
      END;
      --
      BEGIN
         EXECUTE IMMEDIATE 'drop procedure ' || l_procedure_name;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;
   END pr_test_compilation;

   ----------------------------------------------------------------------------

   PROCEDURE pr_create_executable_statement
   (
      i_migration_group          IN VARCHAR2
     ,i_migration_name           IN VARCHAR2
     ,i_compile_test_bool        IN BOOLEAN
     ,i_context                  IN VARCHAR2
     ,o_tab_executable_statement OUT t_vc_tab
     ,o_hash                     OUT RAW
     ,o_tab_errors               OUT t_vc_tab
     ,o_errors_bool              OUT BOOLEAN
   ) IS
      l_migration_code_clob CLOB;
      l_clob                CLOB;
      l_errors_clob         CLOB;
      l_schema              VARCHAR2(30);
      l_touch               VARCHAR2(2000);
      l_initial             VARCHAR2(2000);
      l_rwids               VARCHAR2(2000);
      l_rwids_initial       VARCHAR2(500);
      --
      l_scs         VARCHAR2(4000);
      l_scs_initial VARCHAR2(500);
      --
      l_spaces VARCHAR2(500);
      l_clause VARCHAR2(5);
      l_count  NUMBER;
      l_count2 NUMBER;
      l_value  VARCHAR2(32767);
      l_type   VARCHAR2(500);
      l_pos    NUMBER;
      l_idx    VARCHAR2(500);
      --
      TYPE t_tab IS TABLE OF VARCHAR2(500);
      TYPE t_tab3 IS TABLE OF VARCHAR2(1) INDEX BY VARCHAR2(500);
      TYPE t_tab_col_conv IS TABLE OF VARCHAR2(500) INDEX BY VARCHAR2(500);
      TYPE t_tab_select_list IS TABLE OF VARCHAR2(500) INDEX BY BINARY_INTEGER;
      l_tab_cols        t_tab;
      l_seq_tab         t_tab3;
      l_tab_used        t_tab3;
      l_tab_select_list t_tab_select_list;
      l_tab_col_conv    t_tab_col_conv;
      l_tab_col_used    t_tab_col_conv;
      --
      l_bool_json_handler        BOOLEAN := FALSE;
      l_bool_smart_cache_enabled BOOLEAN := FALSE;
      l_bool_rownum_handler      BOOLEAN := FALSE;
      l_oed_binds_bool           BOOLEAN := FALSE;
      pemh_buf                   pre_etl_migration_header%ROWTYPE;
      l_override_mr_group        pre_etl_migration_detail.mr_group_to_use_for_json%TYPE := NULL;
      l_cur_cols_exists_bool     BOOLEAN;
      l_table_to_use_with_driver VARCHAR2(30);
      --
      const_lf      CONSTANT VARCHAR2(1) := fn_lf;
      const_oed_sql CONSTANT VARCHAR2(2000) := '(SELECT /*+index (on_etl_driver, oed_idx_1) */' ||
                                               fn_lf ||
                                               '                  on_etl_driver.staged_rowid' ||
                                               fn_lf ||
                                               '                , on_etl_driver.grouping_code' ||
                                               fn_lf ||
                                               '                , on_etl_driver.order_within_grouping' ||
                                               fn_lf ||
                                               '                , on_etl_driver.utility_field_1' ||
                                               fn_lf ||
                                               '                , on_etl_driver.utility_field_2' ||
                                               fn_lf ||
                                               '                , on_etl_driver.utility_field_3' ||
                                               fn_lf ||
                                               '                , on_etl_driver.utility_field_4' ||
                                               fn_lf ||
                                               '                , on_etl_driver.utility_field_5' ||
                                               fn_lf ||
                                               '             FROM on_etl_driver' ||
                                               fn_lf ||
                                               '            WHERE on_etl_driver.source_schema = ''<SOURCE_MIG_SCHEMA>''' ||
                                               fn_lf ||
                                               '              AND on_etl_driver.source_table_name = ''<SOURCE_MIG_TABLE>''' ||
                                               fn_lf ||
                                               '              AND decode(partitions_in_set' ||
                                               fn_lf ||
                                               '                        ,NULL' ||
                                               fn_lf ||
                                               '                        ,NULL' ||
                                               fn_lf ||
                                               '                        ,ora_hash(grouping_code, partitions_in_set)) =:thread_number ) migration_driver ';
   
      CURSOR cur_cols
      (
         c_migration_document IN VARCHAR2
        ,c_column_name        IN VARCHAR2
        ,c_mr_group           IN VARCHAR2
      ) IS
         WITH inrg AS
          (SELECT pejl.json_line
                 ,perjl.line_number
                 ,perjl.mr_group
                 ,perjl.relationship_group_id
                 ,pem.table_name
                 ,pem.column_name
                 ,upper(pkg_pre_etl_tools.fn_get_attribute(i_line                     => json_line
                                                          ,i_suppress_get_col_name_vc => 'FALSE')) target_column
             FROM pre_etl_json_lines pejl
             LEFT JOIN pre_etl_related_json_lines perjl
               ON (perjl.document_name = pejl.document_name AND
                  perjl.line_number = pejl.line_number AND
                  perjl.mr_group = c_mr_group)
             LEFT JOIN pre_etl_mapped pem
               ON (pem.relationship_group_id =
                  perjl.relationship_group_id AND
                  pem.mr_group = perjl.mr_group)
            WHERE pejl.document_name = c_migration_document
              AND perjl.relationship_group_id IS NOT NULL
              AND perjl.mr_group = c_mr_group
            ORDER BY perjl.line_number)
         SELECT inrg.target_column
               ,inrg.table_name source_table
               ,inrg.column_name source_column
               ,pkg_pre_etl_tools.fn_replace_dollar_dollar(i_string => pec_fn.comments) AS fn_statement
               ,pkg_pre_etl_tools.fn_replace_dollar_dollar(i_string => pec_lk.comments) AS lk_statement
               ,COUNT(*) over() cnt
           FROM inrg
           LEFT JOIN pre_etl_comments pec_fn
             ON (pec_fn.relationship_group_id =
                inrg.relationship_group_id AND
                pec_fn.mr_group = inrg.mr_group AND
                pec_fn.comment_type = 'F' AND
                pec_fn.comments LIKE '=%')
           LEFT JOIN pre_etl_comments pec_lk
             ON (pec_lk.relationship_group_id =
                inrg.relationship_group_id AND
                pec_lk.mr_group = inrg.mr_group AND
                pec_lk.comment_type = 'L' AND
                (upper(pec_lk.comments) LIKE 'SELECT %' OR
                upper(pec_lk.comments) LIKE 'WITH %'))
          WHERE (table_name || column_name || pec_fn.comments ||
                pec_lk.comments IS NOT NULL)
            AND target_column = upper(c_column_name)
          ORDER BY 2
                  ,3 DESC;
   
      cur_cols_buf cur_cols%ROWTYPE;
   
      -----------------------------------------------------------------------------------
   
      PROCEDURE pr_local_add_to_clob
      (
         i_string            IN VARCHAR2
        ,i_trim_last_lf_bool IN BOOLEAN DEFAULT FALSE
      ) IS
      
      BEGIN
         IF i_trim_last_lf_bool
         THEN
            l_migration_code_clob := rtrim(l_migration_code_clob
                                          ,const_lf);
         END IF;
         l_migration_code_clob := l_migration_code_clob || i_string ||
                                  const_lf;
      END pr_local_add_to_clob;
   
      -----------------------------------------------------------------------------------
   
      PROCEDURE pr_local_add_to_clob
      (
         i_string            IN CLOB
        ,i_trim_last_lf_bool IN BOOLEAN DEFAULT FALSE
      ) IS
      
      BEGIN
         IF i_trim_last_lf_bool
         THEN
            l_migration_code_clob := rtrim(l_migration_code_clob
                                          ,const_lf);
         END IF;
         l_migration_code_clob := l_migration_code_clob || i_string ||
                                  const_lf;
      END pr_local_add_to_clob;
   
      -----------------------------------------------------------------------------------
   
      PROCEDURE pr_local_trim_from_clob(i_string IN VARCHAR2) IS
      BEGIN
         l_migration_code_clob := rtrim(l_migration_code_clob
                                       ,i_string);
      END pr_local_trim_from_clob;
   
      -----------------------------------------------------------------------------------
   
      FUNCTION fn_local_get_clobbed(i_document_name IN VARCHAR2)
         RETURN CLOB IS
         l_return_clob CLOB;
      BEGIN
         FOR i_buf IN (SELECT *
                         FROM pre_etl_json_lines pejl
                        WHERE pejl.document_name = i_document_name
                        ORDER BY pejl.line_number)
         LOOP
            l_return_clob := l_return_clob || i_buf.json_line;
         END LOOP;
         --
         RETURN l_return_clob;
      END fn_local_get_clobbed;
   
      -----------------------------------------------------------------------------------
   
      FUNCTION fn_local_get_value_from_json
      (
         i_json_clob IN VARCHAR2
        ,i_attr      IN VARCHAR2
      ) RETURN VARCHAR2 IS
         l_return VARCHAR2(2000);
      BEGIN
         EXECUTE IMMEDIATE 'SELECT value ' || '  FROM json_table( ''' ||
                           i_json_clob || '''' ||
                           '       ,''$'' columns(value VARCHAR2(30) path ' ||
                           '  ''$.' || i_attr || ''')) AS "dummy"'
            INTO l_return;
         RETURN l_return;
      END fn_local_get_value_from_json;
   
      -----------------------------------------------------------------------------------
   
      PROCEDURE pr_local_process_nextvals(io_clob IN OUT NOCOPY CLOB) IS
         l_pos      NUMBER;
         l_pos2     NUMBER;
         l_seq_name VARCHAR2(30);
      BEGIN
         l_pos := instr(upper(io_clob), '.NEXTVAL');
         WHILE l_pos > 0
         LOOP
            l_pos2     := l_pos - 1;
            l_seq_name := NULL;
            WHILE upper(substr(io_clob, l_pos2, 1)) IN ('A'
                                                       ,'B'
                                                       ,'C'
                                                       ,'D'
                                                       ,'E'
                                                       ,'F'
                                                       ,'G'
                                                       ,'H'
                                                       ,'I'
                                                       ,'J'
                                                       ,'K'
                                                       ,'L'
                                                       ,'M'
                                                       ,'N'
                                                       ,'O'
                                                       ,'P'
                                                       ,'Q'
                                                       ,'R'
                                                       ,'S'
                                                       ,'T'
                                                       ,'U'
                                                       ,'V'
                                                       ,'W'
                                                       ,'X'
                                                       ,'Y'
                                                       ,'Z'
                                                       ,'_')
            LOOP
               l_seq_name := substr(io_clob, l_pos2, 1) || l_seq_name;
               l_pos2     := l_pos2 - 1;
            END LOOP;
            IF l_seq_tab.EXISTS(upper(l_seq_name))
            THEN
               io_clob := substr(io_clob, 1, l_pos - 1) || '.currval' ||
                          substr(io_clob, l_pos + 8);
            ELSE
               l_seq_tab(upper(l_seq_name)) := 'Y';
            END IF;
            l_pos := instr(upper(io_clob), '.NEXTVAL', l_pos + 1);
         END LOOP;
      END pr_local_process_nextvals;
   
      -----------------------------------------------------------------------------------
   
      PROCEDURE pr_local_populate_cols_alias
      (
         i_migration_group IN VARCHAR
        ,i_migration_name  IN VARCHAR2
      ) IS
         l_tab_number      NUMBER := 0;
         l_loop_count      NUMBER := 1;
         l_last_table_name VARCHAR2(30) := '?';
      BEGIN
         FOR i_buf IN (SELECT pedc.table_name || '.' ||
                              pedc.column_name AS src_tab_col
                             ,pedc.table_name AS src_table
                         FROM pre_etl_migration_src pems
                         JOIN pre_etl_db2_columns pedc
                           ON (pedc.table_name = pems.table_name AND
                              pedc.column_pos >= 0)
                        WHERE pems.migration_group = i_migration_group
                          AND pems.migration_name = i_migration_name
                          AND pems.is_inline_view_yn = 'N'
                        ORDER BY pedc.table_name
                                ,pedc.column_pos)
         LOOP
            IF l_last_table_name != i_buf.src_table
            THEN
               l_last_table_name := i_buf.src_table;
               l_tab_number      := l_tab_number + 1;
            END IF;
            l_tab_col_conv(upper(i_buf.src_tab_col)) := 'T' ||
                                                        l_tab_number || '_' ||
                                                        'FIELD_' ||
                                                        lpad(to_char(l_loop_count)
                                                            ,3
                                                            ,'0');
            l_loop_count := l_loop_count + 1;
         END LOOP;
      END pr_local_populate_cols_alias;
   
      -----------------------------------------------------------------------------------
   
      FUNCTION fn_local_translate(i_tab_col IN VARCHAR2) RETURN VARCHAR2 IS
      BEGIN
         IF l_tab_col_conv.EXISTS(upper(i_tab_col))
            AND NOT l_tab_col_used.EXISTS(upper(i_tab_col))
         THEN
            l_tab_col_used(upper(i_tab_col)) := 'Y';
            l_tab_select_list(l_tab_select_list.COUNT + 1) := i_tab_col ||
                                                              ' AS ' ||
                                                              l_tab_col_conv(upper(i_tab_col));
         END IF;
         --
         IF l_tab_col_conv.EXISTS(upper(i_tab_col))
         THEN
            RETURN l_tab_col_conv(upper(i_tab_col));
         ELSE
            RETURN NULL;
         END IF;
      END fn_local_translate;
   
      -----------------------------------------------------------------------------------
   
   BEGIN
      SELECT pemh.*
        INTO pemh_buf
        FROM pre_etl_migration_header pemh
       WHERE pemh.migration_group = i_migration_group
         AND pemh.migration_name = i_migration_name;
   
      pr_local_populate_cols_alias(i_migration_group => i_migration_group
                                  ,i_migration_name  => i_migration_name);
   
      pr_local_add_to_clob(i_string => 'INSERT ALL');
      FOR i_buf IN (SELECT *
                      FROM pre_etl_migration_detail pemd
                     WHERE pemd.migration_group = i_migration_group
                       AND pemd.migration_name = i_migration_name
                     ORDER BY pemd.order_of_exec)
      LOOP
         l_clob := fn_local_get_clobbed(i_document_name => i_buf.migration_document);
         --
         l_schema := fn_local_get_value_from_json(i_json_clob => l_clob
                                                 ,i_attr      => 'SCHEMA_NAME');
         --
         IF fn_touch_possible_yn_cached(i_context         => i_context
                                       ,i_migration_group => i_migration_group
                                       ,i_migration_name  => i_migration_name) = 'Y'
         THEN
            pr_get_touch(i_context         => i_context
                        ,i_migration_group => i_migration_group
                        ,i_migration_name  => i_migration_name
                        ,o_touch           => l_touch);
            IF l_touch IS NOT NULL
            THEN
               pr_local_add_to_clob(i_string => l_touch);
            END IF;
         END IF;
         --                                                      
         pr_local_add_to_clob(i_string => '   WHEN (' ||
                                          i_buf.trigger_sql ||
                                          ') THEN');
         pr_local_add_to_clob(i_string => '     INTO ' || l_schema || '.' ||
                                          fn_local_get_value_from_json(i_json_clob => l_clob
                                                                      ,i_attr      => 'TABLE_NAME'));
      
         EXECUTE IMMEDIATE 'SELECT column_name ' ||
                           '  FROM json_table( ''' || l_clob || '''' ||
                           '       ,''$.COLUMNS[*]'' columns(column_name VARCHAR2(30) path ' ||
                           '  ''$.COLUMN_NAME'')) AS "dummy"' BULK
                           COLLECT
            INTO l_tab_cols;
         --
         FOR i IN l_tab_cols.FIRST .. l_tab_cols.LAST
         LOOP
            pr_local_add_to_clob(i_string => '     ' || (CASE i
                                                WHEN 1 THEN
                                                 '('
                                                ELSE
                                                 ','
                                             END) || l_tab_cols(i));
         END LOOP;
         --
         pr_local_trim_from_clob(',' || const_lf);
         pr_local_add_to_clob(i_string => ')');
         --
         pr_local_add_to_clob(i_string => '     VALUES');
         l_initial := '        (';
         --
         FOR i IN l_tab_cols.FIRST .. l_tab_cols.LAST
         LOOP
            l_cur_cols_exists_bool := FALSE;
            l_count                := 1;
            l_count2               := 0;
            --
            FOR cur_cols_buf IN cur_cols(c_migration_document => i_buf.migration_document
                                        ,c_column_name        => l_tab_cols(i)
                                        ,c_mr_group           => pemh_buf.mr_group_to_use)
            LOOP
               --
               IF l_count2 = 0
               THEN
                  l_count2 := cur_cols_buf.cnt + 1;
               END IF;
               l_count2 := l_count2 - 1;
               --
               l_cur_cols_exists_bool := TRUE;
               --
               IF l_count > 1
               THEN
                  IF l_type = 'LOOKUP'
                  THEN
                     cur_cols_buf.lk_statement := rtrim(ltrim(l_value
                                                             ,'(')
                                                       ,')');
                     cur_cols_buf.fn_statement := NULL;
                  ELSIF l_type = 'FUNCTION'
                  THEN
                     cur_cols_buf.fn_statement := CASE
                                                     WHEN substr(l_value, 1, 1) != '=' THEN
                                                      '=' || l_value
                                                     ELSE
                                                      l_value
                                                  END;
                     cur_cols_buf.lk_statement := NULL;
                  ELSE
                     raise_application_error(-20000
                                            ,'Multi mapping but no guidance on how to use the mapped values.  Function or lookup required.');
                  END IF;
               END IF;
               --
               -- Keep track of the tables used to drive the query for the insert
               -- so we can do the select at the end.
               IF cur_cols_buf.source_table IS NOT NULL
               THEN
                  l_tab_used(upper(cur_cols_buf.source_table)) := 'Y';
               END IF;
               --
               --
               IF (cur_cols_buf.fn_statement IS NULL AND
                  cur_cols_buf.lk_statement IS NULL)
               THEN
                  IF cur_cols_buf.source_table ||
                     cur_cols_buf.source_column IS NULL
                  THEN
                     -- no function, lookup OR mapping...
                     l_type  := 'NULL';
                     l_value := 'NULL';
                  ELSE
                     -- Straight Mapping.
                     l_type  := 'MAPPING';
                     l_value := fn_local_translate(i_tab_col => cur_cols_buf.source_table || '.' ||
                                                                cur_cols_buf.source_column);
                  END IF;
               ELSIF (cur_cols_buf.fn_statement IS NOT NULL AND
                     cur_cols_buf.lk_statement IS NOT NULL AND
                     substr(cur_cols_buf.fn_statement, 1, 1) = '=' AND
                     (ltrim(upper(substr(cur_cols_buf.lk_statement
                                         ,1
                                         ,6))) = 'SELECT' OR
                     ltrim(upper(substr(cur_cols_buf.lk_statement
                                         ,1
                                         ,4))) = 'WITH'))
               THEN
                  -- Has two statement comments (i.e. 2 actionable bits of work). fn and lk
                  -- A lookup must not reference a function WHILST AT THE SAME time the function
                  -- references the lookup.
                  IF instr(upper(cur_cols_buf.lk_statement)
                          ,g_tool_const_function) > 0
                     AND instr(upper(cur_cols_buf.fn_statement)
                              ,g_tool_const_lookup) > 0
                  THEN
                     ex_raise_nested_lk_fn(i_error_text => i_buf.migration_document || '.' ||
                                                           l_tab_cols(i));
                  END IF;
                  --
                  -- The lookup must reference a function (otherwise which would be the value?) 
                  -- OR
                  -- The function must reference a lookup... 
                  --
                  -- If the function is referencing the lookup then its the function that is the value (with the lookup used)
                  -- If the lookup is referencing the function then the lookup is the value used (with a function helping the lookup)
                  IF instr(upper(cur_cols_buf.lk_statement)
                          ,g_tool_const_function) > 0
                  THEN
                     -- The value is the lookup using the function.
                     l_type  := 'LOOKUP';
                     l_value := '(' || REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => cur_cols_buf.lk_statement
                                                                                          ,i_keyword   => g_tool_const_function)
                                              ,g_tool_const_function
                                              ,ltrim(cur_cols_buf.fn_statement
                                                    ,'=')) || ')';
                  ELSIF instr(upper(cur_cols_buf.fn_statement)
                             ,g_tool_const_lookup) > 0
                  THEN
                     -- The value is the function using the lookup.
                     l_type  := 'FUNCTION';
                     l_value := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => cur_cols_buf.fn_statement
                                                                                   ,i_keyword   => g_tool_const_lookup)
                                       ,g_tool_const_lookup
                                       ,'(' ||
                                        cur_cols_buf.lk_statement || ')');
                  ELSE
                     -- The lookup doesn't doesn't use a function AND the function doesn't use a lookup...
                     -- They're just 2 usable values we can't decide which one to use.
                     ex_cannot_choose_fn_or_lk;
                  END IF;
                  --
               ELSIF (cur_cols_buf.fn_statement IS NOT NULL AND
                     substr(cur_cols_buf.fn_statement, 1, 1) = '=')
               THEN
                  -- Use the function.
                  l_type  := 'FUNCTION';
                  l_value := substr(cur_cols_buf.fn_statement, 2);
                  IF upper(l_value) = 'ROWNUM'
                  THEN
                     l_value               := 'migration_rownum_pseudo';
                     l_bool_rownum_handler := TRUE;
                  END IF;
               ELSIF (cur_cols_buf.lk_statement IS NOT NULL AND
                     (ltrim(upper(substr(cur_cols_buf.lk_statement
                                         ,1
                                         ,6))) = 'SELECT' OR
                     ltrim(upper(substr(cur_cols_buf.lk_statement
                                         ,1
                                         ,4))) = 'WITH'))
               THEN
                  -- Use the lookup.
                  l_type  := 'LOOKUP';
                  l_value := '(' || cur_cols_buf.lk_statement || ')';
               ELSE
                  -- There is no lookup or function.
                  l_type  := 'NULL';
                  l_value := 'NULL';
               END IF;
            
               --
               -- If we're assembling a JSON structure as part of our import we'll need to do a
               -- number of things.  We'll need to pass the appropriate document name into the 
               -- json handler, and we'll need to pass to the handler a name value pair table  
               -- which represents the current row.
               IF instr(upper(l_value), g_tool_const_json) > 0
               THEN
                  l_override_mr_group := i_buf.mr_group_to_use_for_json;
                  l_value             := fn_set_json_handler(i_value             => l_value
                                                            ,i_mr_group          => i_buf.mr_group_to_use_for_json
                                                            ,i_mig_group         => i_migration_group
                                                            ,i_introspect_step   => i_migration_group || ':' ||
                                                                                    i_migration_name
                                                            ,i_use_driver_bool   => fn_has_oed_driver_bool(i_migration_group => i_migration_group
                                                                                                          ,i_migration_name  => i_migration_name)
                                                            ,i_smart_cache_attrs => i_buf.smart_cache_attrs);
                  l_bool_json_handler := TRUE;
                  IF i_buf.smart_cache_attrs IS NOT NULL
                  THEN
                     l_bool_smart_cache_enabled := TRUE;
                  END IF;
               END IF;
               --
               l_value := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_value
                                                                             ,i_keyword   => g_tool_const_src)
                                 ,g_tool_const_src
                                 ,pemh_buf.staged_schema);
               --
               l_value := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_value
                                                                             ,i_keyword   => g_tool_const_mapped ||
                                                                                             (CASE
                                                                                                WHEN cur_cols_buf.cnt > 1 THEN
                                                                                                 '#' || to_char(l_count2)
                                                                                                ELSE
                                                                                                 NULL
                                                                                             END))
                                 ,g_tool_const_mapped || (CASE
                                     WHEN cur_cols_buf.cnt > 1 THEN
                                      '#' || to_char(l_count2)
                                     ELSE
                                      NULL
                                  END)
                                 ,fn_local_translate(i_tab_col => cur_cols_buf.source_table || '.' ||
                                                                  cur_cols_buf.source_column));
               --
               --
               l_value := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_value
                                                                             ,i_keyword   => g_tool_const_lookup)
                                 ,g_tool_const_lookup
                                 ,'''''');
               --
               --
               IF fn_has_oed_driver_bool(i_migration_group => i_migration_group
                                        ,i_migration_name  => i_migration_name)
               THEN
                  FOR i2 IN 1 .. 5
                  LOOP
                     l_value := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_varchar2(i_statement => l_value
                                                                                   ,i_keyword   => g_tool_const_uf ||
                                                                                                   to_char(i2))
                                       ,g_tool_const_uf ||
                                        to_char(i2)
                                       ,'mig_driver_utility_field_' ||
                                        to_char(i2));
                  END LOOP;
               END IF;
               --
               l_count := l_count + 1;
            END LOOP;
            --
            IF NOT l_cur_cols_exists_bool
            THEN
               -- No mapping, no function, no lookup... we need to put null
               pr_local_add_to_clob(i_string => l_initial || 'NULL');
            ELSE
               l_spaces := fn_lf || lpad(' ', length(l_initial), ' ');
               pr_local_add_to_clob(i_string => REPLACE(l_initial ||
                                                        ltrim(l_value
                                                             ,'=')
                                                       ,fn_lf
                                                       ,l_spaces));
            END IF;
            l_initial := '        ,';
         END LOOP;
         pr_local_add_to_clob(i_string => '        )');
      END LOOP;
      --
      pr_local_process_nextvals(io_clob => l_migration_code_clob);
      --
      --  ==========================================================
      --  BUILD THE SQL TO POWER THE INSERT
      --  ==========================================================      
      --
      l_initial := '   WITH ';
      FOR i_buf IN (SELECT pems.table_name
                          ,pemsiv.source_code
                      FROM pre_etl_migration_src pems
                      JOIN pre_etl_migration_src_inline_v pemsiv
                        ON (pemsiv.inline_view_name = pems.table_name)
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'Y')
      LOOP
         pr_local_add_to_clob(i_string => l_initial ||
                                          i_buf.table_name || ' AS (' ||
                                          i_buf.source_code || ')');
         l_initial := '   ,';
      END LOOP;
      --
      l_initial := '   SELECT ' ||
                   fn_add_hint(i_migration_group => i_migration_group
                              ,i_migration_name  => i_migration_name);
      IF l_tab_select_list.COUNT > 0
      THEN
         FOR i IN 1 .. l_tab_select_list.LAST
         LOOP
            pr_local_add_to_clob(i_string => l_initial ||
                                             l_tab_select_list(i));
            l_initial := '        , ';
         END LOOP;
      END IF;
      --
      IF fn_has_oed_driver_bool(i_migration_group => i_migration_group
                               ,i_migration_name  => i_migration_name)
      THEN
         FOR i IN 1 .. 5
         LOOP
            pr_local_add_to_clob(i_string => l_initial ||
                                             'migration_driver.utility_field_' ||
                                             to_char(i) ||
                                             ' AS mig_driver_utility_field_' ||
                                             to_char(i));
         END LOOP;
      END IF;
      --
      IF fn_touch_possible_yn_cached(i_context         => i_context
                                    ,i_migration_group => i_migration_group
                                    ,i_migration_name  => i_migration_name) = 'Y'
      THEN
         pr_get_touch(i_context         => i_context
                     ,i_migration_group => i_migration_group
                     ,i_migration_name  => i_migration_name
                     ,o_touch           => l_touch);
         IF l_touch IS NOT NULL
         THEN
            IF fn_has_oed_driver_bool(i_migration_group => i_migration_group
                                     ,i_migration_name  => i_migration_name)
            THEN
               pr_local_add_to_clob(i_string => l_initial ||
                                                'migration_driver.staged_rowid    AS mig_driver_staged_rowid');
            ELSE
               FOR i_buf IN (SELECT lower(pems.table_name) AS table_name
                               FROM pre_etl_migration_src pems
                              WHERE pems.migration_group =
                                    i_migration_group
                                AND pems.migration_name =
                                    i_migration_name)
               LOOP
                  pr_local_add_to_clob(i_string => l_initial ||
                                                   i_buf.table_name ||
                                                   '.rowid    AS mig_driver_staged_rowid');
               END LOOP;
            END IF;
         END IF;
      END IF;
      --
      IF l_bool_rownum_handler
      THEN
         pr_local_add_to_clob(i_string => l_initial ||
                                          'ROWNUM AS migration_rownum_pseudo');
      END IF;
      --
      -- Add in the subquery factored columns...
      FOR i_buf IN (SELECT pems.table_name
                      FROM pre_etl_migration_src pems
                      JOIN pre_etl_migration_src_inline_v pemsiv
                        ON (pemsiv.inline_view_name = pems.table_name)
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'Y')
      LOOP
         pr_local_add_to_clob(i_string => l_initial ||
                                          i_buf.table_name || '.*');
      END LOOP;
      --
      --
      -- If we have JSON to populate
      IF l_bool_json_handler
      THEN
         --
         --
         IF l_bool_smart_cache_enabled
         THEN
            l_scs         := NULL;
            l_scs_initial := lower(USER) ||
                             '.pkg_pre_etl_tools.fn_get_hash_for_clob(' ||
                             '''MIG''||';
            FOR i_buf IN (SELECT pemd.smart_cache_key
                            FROM pre_etl_migration_detail pemd
                           WHERE pemd.migration_group =
                                 i_migration_group
                             AND pemd.migration_name =
                                 i_migration_name)
            LOOP
               l_scs         := l_scs || l_scs_initial ||
                                i_buf.smart_cache_key;
               l_scs_initial := '||''.''||';
            END LOOP;
            pr_local_add_to_clob(i_string => l_initial || l_scs ||
                                             ') AS MIG_SMART_CACHE_KEY');
         END IF;
         --
         --
         -- Add rowids for json cache key.
         -- We only need a MIG_CACHE_KEY if we're using JSON somewhere.
         l_rwids         := NULL;
         l_rwids_initial := lower(USER) ||
                            '.pkg_pre_etl_tools.fn_get_hash_for_clob(' ||
                            '''MIG''||';
         FOR i_buf IN (SELECT pems.table_name
                         FROM pre_etl_migration_src pems
                        WHERE pems.migration_group = i_migration_group
                          AND pems.migration_name = i_migration_name
                          AND pems.is_inline_view_yn = 'N')
         LOOP
            l_rwids         := l_rwids || l_rwids_initial ||
                               i_buf.table_name || '.rowid';
            l_rwids_initial := '||''.''||';
         END LOOP;
         --
         --
         IF fn_has_oed_driver_bool(i_migration_group => i_migration_group
                                  ,i_migration_name  => i_migration_name)
         THEN
            l_rwids := l_rwids || '||''/''||' || fn_lf;
            l_rwids := l_rwids || lpad(' ', 63, ' ');
            FOR i IN 1 .. 5
            LOOP
               l_rwids := l_rwids ||
                          'migration_driver.utility_field_' ||
                          to_char(i) || (CASE i
                             WHEN 5 THEN
                              NULL
                             ELSE
                              '||''/''||' || fn_lf ||
                              lpad(' ', 63, ' ')
                          END);
            END LOOP;
         END IF;
         --
         pr_local_add_to_clob(i_string => l_initial || l_rwids ||
                                          ') AS MIG_CACHE_KEY');
         --
         --
         pr_local_add_to_clob(i_string => l_initial ||
                                          fn_nv_pairs(i_migration_group => i_migration_group
                                                     ,i_migration_name  => i_migration_name
                                                     ,i_mr_group        => nvl(l_override_mr_group
                                                                              ,pemh_buf.mr_group_to_use)));
      END IF;
   
      l_initial                  := '     FROM ';
      l_table_to_use_with_driver := NULL;
      FOR i_buf IN (SELECT pems.table_name
                          ,pems.use_with_on_etl_driver_yn
                          ,pems.join_type
                          ,pems.where_or_join_predicates
                      FROM pre_etl_migration_src pems
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'N'
                     ORDER BY pems.order_by ASC)
      LOOP
         --
         IF i_buf.use_with_on_etl_driver_yn = 'Y'
         THEN
            l_table_to_use_with_driver := i_buf.table_name;
         END IF;
         --
         IF i_buf.join_type IS NOT NULL
         THEN
            pr_local_add_to_clob(i_string => '        ' || i_buf.join_type ||
                                             ' JOIN ' ||
                                             pemh_buf.staged_schema ||
                                             (CASE nvl(pemh_buf.staged_schema
                                                 ,'##NULL##')
                                                WHEN '##NULL##' THEN
                                                 NULL
                                                ELSE
                                                 '.'
                                             END) || i_buf.table_name ||
                                             ' ON (' ||
                                             i_buf.where_or_join_predicates ||
                                             (CASE
                                                WHEN i_buf.where_or_join_predicates IS NOT NULL THEN
                                                 ' AND '
                                                ELSE
                                                 NULL
                                             END) || lower(i_buf.table_name) ||
                                             '.migration_batch_id = ' ||
                                             lower(g_tool_const_batch) || ')');
         ELSE
            pr_local_add_to_clob(i_string => l_initial ||
                                             pemh_buf.staged_schema ||
                                             (CASE nvl(pemh_buf.staged_schema
                                                 ,'##NULL##')
                                                WHEN '##NULL##' THEN
                                                 NULL
                                                ELSE
                                                 '.'
                                             END) || i_buf.table_name);
            IF l_tab_used.EXISTS(upper(i_buf.table_name))
            THEN
               l_tab_used.delete(upper(i_buf.table_name));
            END IF;
            l_initial := '        , ';
         END IF;
      END LOOP;
      --
      FOR i_buf IN (SELECT pems.table_name
                          ,pems.join_type
                          ,pems.where_or_join_predicates
                      FROM pre_etl_migration_src pems
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'Y'
                     ORDER BY pems.order_by)
      LOOP
         pr_local_add_to_clob(i_string => i_buf.join_type || ' JOIN ' ||
                                          i_buf.table_name || ' ON (' ||
                                          i_buf.where_or_join_predicates || ')');
      END LOOP;
      --
      IF l_table_to_use_with_driver IS NOT NULL
      THEN
         l_oed_binds_bool := TRUE;
         pr_local_add_to_clob(i_string => l_initial ||
                                          REPLACE(REPLACE(const_oed_sql
                                                         ,'<SOURCE_MIG_SCHEMA>'
                                                         ,pemh_buf.staged_schema)
                                                 ,'<SOURCE_MIG_TABLE>'
                                                 ,l_table_to_use_with_driver));
      END IF;
      --
      l_initial := NULL;
      l_count   := 0;
      l_clause  := 'WHERE';
      FOR i_buf IN (SELECT *
                      FROM pre_etl_migration_src pems
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'N'
                       AND pems.join_type IS NULL
                     ORDER BY decode(upper(substr(TRIM(pems.where_or_join_predicates)
                                                 ,1
                                                 ,5))
                                    ,'WHERE'
                                    ,0
                                    ,pems.order_by) ASC)
      LOOP
         --
         IF l_count = 0
         THEN
            l_initial := '    WHERE ';
         END IF;
         --
         l_count := l_count + 1;
         --
         IF upper(substr(TRIM(i_buf.where_or_join_predicates), 1, 5)) =
            'WHERE'
         THEN
            l_clause := '  AND';
            pr_local_add_to_clob(i_string => l_initial ||
                                             ltrim(substr(i_buf.where_or_join_predicates
                                                         ,6)));
            l_initial := '                 ';
         ELSIF i_buf.where_or_join_predicates IS NOT NULL
         THEN
            l_clause := '  AND';
            pr_local_add_to_clob(i_string => l_initial ||
                                             ltrim(i_buf.where_or_join_predicates));
            l_initial := '                 ';
         END IF;
      END LOOP;
      --     
      --
      l_initial := '    ' || l_clause;
      FOR i_buf IN (SELECT *
                      FROM pre_etl_migration_src pems
                      JOIN pre_etl_migration_header pemh
                        ON (pemh.migration_group =
                           pems.migration_group AND
                           pemh.migration_name = pems.migration_name)
                     WHERE pems.migration_group = i_migration_group
                       AND pems.migration_name = i_migration_name
                       AND pems.is_inline_view_yn = 'N'
                       AND pems.join_type IS NULL
                       AND pemh.staged_schema != USER
                     ORDER BY decode(upper(substr(TRIM(pems.where_or_join_predicates)
                                                 ,1
                                                 ,5))
                                    ,'WHERE'
                                    ,0
                                    ,pems.order_by) ASC)
      LOOP
         pr_local_add_to_clob(i_string            => fn_lf ||
                                                     l_initial || ' ' ||
                                                     i_buf.table_name ||
                                                     '.migration_batch_id = ' ||
                                                     lower(g_tool_const_batch)
                             ,i_trim_last_lf_bool => TRUE);
         l_clause := 'AND';
      END LOOP;
      --
      --
      IF l_table_to_use_with_driver IS NOT NULL
      THEN
         l_initial := '                 ';
         pr_local_add_to_clob(i_string            => l_initial ||
                                                     REPLACE(REPLACE(REPLACE(fn_lf ||
                                                                             '      <CLAUSE> ( <SOURCE_MIG_SCHEMA>.<SOURCE_MIG_TABLE>.rowid = migration_driver.staged_rowid '
                                                                            ,'<SOURCE_MIG_SCHEMA>'
                                                                            ,pemh_buf.staged_schema)
                                                                    ,'<SOURCE_MIG_TABLE>'
                                                                    ,l_table_to_use_with_driver)
                                                            ,'<CLAUSE>'
                                                            ,l_clause) || ')' ||
                                                     fn_lf ||
                                                     q'[      ORDER BY migration_driver.grouping_code
              ,migration_driver.order_within_grouping ]'
                             ,i_trim_last_lf_bool => TRUE);
      END IF;
   
      pr_local_add_to_clob(i_string            => ';'
                          ,i_trim_last_lf_bool => TRUE);
      --
      -- Handle ROWID 
      l_migration_code_clob := REPLACE(l_migration_code_clob
                                      ,fn_mck
                                      ,'MIG_CACHE_KEY');
      l_migration_code_clob := REPLACE(l_migration_code_clob
                                      ,fn_sck
                                      ,'MIG_SMART_CACHE_KEY');
   
      --
      o_hash := fn_get_hash_for_clob(i_clob => l_migration_code_clob);
      --
   
      IF i_compile_test_bool
      THEN
         o_errors_bool := FALSE;
         pr_test_compilation(i_statement_clob => l_migration_code_clob
                            ,i_oed_binds_bool => l_oed_binds_bool
                            ,i_context        => i_context
                            ,o_errors_clob    => l_errors_clob);
         --
         IF l_errors_clob IS NOT NULL
         THEN
            o_errors_bool := TRUE;
         END IF;
      
         IF NOT o_errors_bool
            AND l_tab_used.COUNT > 0
         THEN
            o_tab_errors(1) := 'Not all tables connected to the migration targets are used.' ||
                               fn_lf;
            l_idx := l_tab_used.FIRST;
            WHILE l_idx IS NOT NULL
            LOOP
               o_tab_errors(1) := o_tab_errors(1) ||
                                  'Check inclusion of ' || l_idx ||
                                  fn_lf;
               l_idx := l_tab_used.next(l_idx);
            END LOOP;
         ELSE
            o_tab_errors := fn_cut_clob_to_tab(i_clob => l_errors_clob);
         END IF;
         --
         o_tab_executable_statement := fn_cut_clob_to_tab(i_clob => l_migration_code_clob);
      END IF;
   EXCEPTION
      WHEN OTHERS THEN
         o_errors_bool := TRUE;
         l_errors_clob := SQLERRM || fn_lf(i_quantity => 2) ||
                          l_migration_code_clob || fn_lf ||
                          '^^^ Failed here.';
         o_tab_errors  := fn_cut_clob_to_tab(i_clob => l_errors_clob);
         o_tab_executable_statement.delete;
   END pr_create_executable_statement;

   ----------------------------------------------------------------------------

   PROCEDURE pr_set_executable_statement
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
     ,i_statement       IN VARCHAR2
   ) IS
   BEGIN
      UPDATE pre_etl_migration_header pemh
         SET pemh.executable_statement     = i_statement
            ,pemh.statement_has_errors_ynu = 'U'
       WHERE pemh.migration_group = i_migration_group
         AND pemh.migration_name = i_migration_name;
   END pr_set_executable_statement;

   ----------------------------------------------------------------------------

   PROCEDURE pr_validate_statement
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
     ,i_context         IN VARCHAR2
     ,o_tab_errors      OUT t_vc_tab
     ,o_errors_bool     OUT BOOLEAN
   ) IS
      l_statement_clob    CLOB;
      l_test_clob         CLOB;
      l_errors_clob       CLOB;
      l_errors_found_bool BOOLEAN;
      l_procedure_name    VARCHAR(30) := 'test_comp_' ||
                                         to_char(systimestamp
                                                ,'YYYYMMDDHH24MISSFF6');
   BEGIN
   
      --
      SELECT pemh.executable_statement
        INTO l_statement_clob
        FROM pre_etl_migration_header pemh
       WHERE pemh.migration_group = i_migration_group
         AND pemh.migration_name = i_migration_name;
      --
      -- l_statement_clob := replace (l_statement_clob,chr(39),chr(39)||chr(39));
      --
      l_test_clob := 'CREATE OR REPLACE PROCEDURE ' ||
                     l_procedure_name || ' IS ' || fn_lf ||
                     'BEGIN IF 1=2 THEN ' || fn_lf || ' BEGIN ' ||
                     fn_lf || l_statement_clob || fn_lf || ' END; ' ||
                     fn_lf || 'END IF;' || fn_lf || ' END ' ||
                     l_procedure_name || ';';
   
      IF instr(upper(l_statement_clob), g_tool_const_batch) > 0
      THEN
         l_test_clob := REPLACE(pkg_pre_etl_tools.fn_upper_keyword_clob(i_statement => l_test_clob
                                                                       ,i_keyword   => g_tool_const_batch)
                               ,g_tool_const_batch
                               ,'0');
      END IF;
      --
      BEGIN
         EXECUTE IMMEDIATE fn_contextualize(i_subject => l_test_clob
                                           ,i_context => i_context);
      EXCEPTION
         WHEN OTHERS THEN
            l_errors_found_bool := FALSE;
            IF instr(upper(l_statement_clob), g_tool_const_batch) > 0
            THEN
               l_errors_clob := l_errors_clob ||
                                'Check that you have not enclosed ' ||
                                g_tool_const_batch || ' in quotes.' ||
                                fn_lf;
               l_errors_clob := l_errors_clob ||
                                'NB: For validation purposes ' ||
                                g_tool_const_batch ||
                                ' is converted to 0' || fn_lf;
               l_errors_clob := l_errors_clob ||
                                '====================================================' ||
                                fn_lf || fn_lf;
            END IF;
            FOR i_buf IN (SELECT (ue.line - 3) AS line
                                ,ue.text error_text
                                ,ds.text code_text
                            FROM user_errors ue
                            JOIN user_source ds
                              ON (ds.name = ue.name AND
                                 ds.type = ue.type AND
                                 ds.line = ue.line)
                           WHERE ue.name = upper(l_procedure_name)
                           ORDER BY sequence DESC)
            LOOP
               l_errors_found_bool := TRUE;
               l_errors_clob       := l_errors_clob ||
                                      rpad(i_buf.line, 8, ' ') ||
                                      i_buf.error_text || fn_lf ||
                                      '        ' || i_buf.code_text ||
                                      fn_lf;
            END LOOP;
            --
            IF NOT l_errors_found_bool
            THEN
               l_errors_clob := l_errors_clob ||
                                'Unexpected Error : ' || SQLERRM ||
                                fn_lf;
            END IF;
            --
            o_errors_bool := TRUE;
            l_errors_clob := l_errors_clob || fn_lf;
            l_errors_clob := l_errors_clob || 'Process Statement' ||
                             fn_lf;
            l_errors_clob := l_errors_clob || '===================' ||
                             fn_lf;
            l_errors_clob := l_errors_clob || l_statement_clob;
            --
            o_tab_errors := fn_cut_clob_to_tab(i_clob => l_errors_clob);
      END;
   
      BEGIN
         EXECUTE IMMEDIATE 'drop procedure ' || l_procedure_name;
      EXCEPTION
         WHEN OTHERS THEN
            NULL;
      END;
   END pr_validate_statement;

   ----------------------------------------------------------------------------

   PROCEDURE pr_update_pemh_statement
   (
      i_migration_group IN VARCHAR2
     ,i_migration_name  IN VARCHAR2
     ,i_has_errors_ynu  IN VARCHAR2
     ,i_tab_statement   IN t_vc_tab
   ) IS
      l_clob CLOB;
   BEGIN
      IF i_tab_statement.COUNT > 0
      THEN
         FOR i IN i_tab_statement.FIRST .. i_tab_statement.LAST
         LOOP
            l_clob := l_clob || i_tab_statement(i);
         END LOOP;
      END IF;
      --
      UPDATE pre_etl_migration_header pemh
         SET pemh.statement_has_errors_ynu = i_has_errors_ynu
            ,pemh.executable_statement     = l_clob
       WHERE pemh.migration_group = i_migration_group
         AND pemh.migration_name = i_migration_name;
      --
   END pr_update_pemh_statement;

   ----------------------------------------------------------------------------

   PROCEDURE pr_copy_move_group
   (
      i_migration_group        IN VARCHAR2
     ,i_migration_name         IN VARCHAR2
     ,i_target_migration_group IN VARCHAR2
     ,i_mode                   IN VARCHAR2
   ) IS
   
      l_dummy   VARCHAR2(1);
      l_counter NUMBER;
      l_max_ooe NUMBER;
      l_trim    NUMBER;
      --
      FUNCTION fn_get_number_add_1
      (
         i_migration_name IN VARCHAR2
        ,o_trim           OUT NUMBER
      ) RETURN NUMBER IS
         --
         l_last_good_number NUMBER := NULL;
         l_pos              NUMBER := -1;
         --
         FUNCTION fn_is_number(i_value IN VARCHAR2) RETURN BOOLEAN IS
            l_dummy NUMBER;
         BEGIN
            l_dummy := to_number(i_value);
            RETURN TRUE;
         EXCEPTION
            WHEN OTHERS THEN
               RETURN FALSE;
         END fn_is_number;
      BEGIN
         WHILE TRUE
         LOOP
            IF fn_is_number(i_value => substr(i_migration_name, l_pos))
            THEN
               l_last_good_number := to_number(substr(i_migration_name
                                                     ,l_pos));
               l_pos              := l_pos - 1;
            ELSE
               EXIT;
            END IF;
         END LOOP;
         --
         o_trim := abs(l_pos) - 1;
         --
         -- This would be null if the migration name doesn't end in a number.
         RETURN nvl(l_last_good_number, 1) + 1;
      END fn_get_number_add_1;
   
   BEGIN
      IF i_mode NOT IN ('COPY', 'MOVE')
      THEN
         raise_application_error(-20000, 'Unknown mode. ' || i_mode);
      END IF;
      --
   
      BEGIN
         SELECT NULL
           INTO l_dummy
           FROM pre_etl_migration_header pemh
          WHERE pemh.migration_group =
                upper(i_target_migration_group)
            AND pemh.migration_name = i_migration_name;
         --
         l_counter := fn_get_number_add_1(i_migration_name => i_migration_name
                                         ,o_trim           => l_trim);
      EXCEPTION
         WHEN no_data_found THEN
            l_trim    := 0;
            l_counter := NULL;
      END;
      --
      SELECT nvl(MAX(order_of_exec), 0) + 1
        INTO l_max_ooe
        FROM pre_etl_migration_header pemh
       WHERE pemh.migration_group = upper(i_target_migration_group);
   
      --
      IF i_mode IN ('COPY', 'MOVE')
      THEN
         INSERT INTO pre_etl_migration_header
            (migration_group
            ,migration_name
            ,migration_description
            ,staged_schema
            ,mr_group_to_use
            ,order_of_exec
            ,executable_statement
            ,statement_has_errors_ynu
            ,header_type)
            SELECT upper(i_target_migration_group)
                  ,substr(pemh.migration_name
                         ,1
                         ,length(pemh.migration_name) - l_trim) ||
                   to_char(l_counter)
                  ,pemh.migration_description
                  ,pemh.staged_schema
                  ,pemh.mr_group_to_use
                  ,l_max_ooe
                  ,pemh.executable_statement
                  ,pemh.statement_has_errors_ynu
                  ,pemh.header_type
              FROM pre_etl_migration_header pemh
             WHERE upper(pemh.migration_group) =
                   upper(i_migration_group)
               AND pemh.migration_name = i_migration_name;
         --
         --
         INSERT INTO pre_etl_migration_detail
            (migration_group
            ,migration_name
            ,migration_document
            ,order_of_exec
            ,trigger_sql
            ,smart_cache_attrs
            ,touch_migration_status_yn
            ,mr_group_to_use_for_json
            ,smart_cache_key)
            SELECT upper(i_target_migration_group)
                  ,substr(pemd.migration_name
                         ,1
                         ,length(pemd.migration_name) - l_trim) ||
                   to_char(l_counter)
                  ,pemd.migration_document
                  ,pemd.order_of_exec
                  ,pemd.trigger_sql
                  ,pemd.smart_cache_attrs
                  ,pemd.touch_migration_status_yn
                  ,pemd.mr_group_to_use_for_json
                  ,pemd.smart_cache_key
              FROM pre_etl_migration_detail pemd
             WHERE upper(pemd.migration_group) =
                   upper(i_migration_group)
               AND pemd.migration_name = i_migration_name;
         --
         --
         INSERT INTO pre_etl_migration_src
            (migration_group
            ,migration_name
            ,table_name
            ,where_or_join_predicates
            ,use_with_on_etl_driver_yn
            ,join_type
            ,is_inline_view_yn
            ,order_by)
            SELECT upper(i_target_migration_group)
                  ,substr(pems.migration_name
                         ,1
                         ,length(pems.migration_name) - l_trim) ||
                   to_char(l_counter)
                  ,pems.table_name
                  ,pems.where_or_join_predicates
                  ,pems.use_with_on_etl_driver_yn
                  ,pems.join_type
                  ,pems.is_inline_view_yn
                  ,pems.order_by
              FROM pre_etl_migration_src pems
             WHERE upper(pems.migration_group) =
                   upper(i_migration_group)
               AND pems.migration_name = i_migration_name;
      END IF;
      --
      IF i_mode = 'MOVE'
      THEN
         DELETE FROM pre_etl_migration_header pemh
          WHERE upper(pemh.migration_group) =
                upper(i_migration_group)
            AND pemh.migration_name = i_migration_name;
         DELETE FROM pre_etl_migration_detail pemd
          WHERE upper(pemd.migration_group) =
                upper(i_migration_group)
            AND pemd.migration_name = i_migration_name;
         DELETE FROM pre_etl_migration_src pems
          WHERE upper(pems.migration_group) =
                upper(i_migration_group)
            AND pems.migration_name = i_migration_name;
      END IF;
   END pr_copy_move_group;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_mappings_for_doc
   (
      i_document_name IN VARCHAR2
     ,i_mr_group      IN VARCHAR2
   ) IS
      TYPE t_tab IS TABLE OF VARCHAR2(30) INDEX BY VARCHAR2(50);
      l_tab t_tab;
      l_idx VARCHAR2(50);
   BEGIN
      FOR i_buf IN (SELECT rowidtochar(pec.rowid) AS pec_rid
                          ,rowidtochar(pem.rowid) AS pem_rid
                          ,rowidtochar(perjl.rowid) AS perjl_rid
                          ,(SELECT COUNT(*)
                              FROM pre_etl_related_json_lines perjl2
                             WHERE perjl2.relationship_group_id =
                                   perjl.relationship_group_id
                               AND perjl2.mr_group = perjl.mr_group) AS count_in_group
                      FROM pre_etl_related_json_lines perjl
                      LEFT JOIN pre_etl_mapped pem
                        ON (perjl.relationship_group_id =
                           pem.relationship_group_id AND
                           perjl.mr_group = pem.mr_group)
                      LEFT JOIN pre_etl_json_lines pejl
                        ON (pejl.document_name = perjl.document_name AND
                           pejl.line_number = perjl.line_number)
                      LEFT JOIN pre_etl_comments pec
                        ON (pec.relationship_group_id =
                           perjl.relationship_group_id AND
                           pec.mr_group = perjl.mr_group)
                     WHERE perjl.document_name = i_document_name
                       AND perjl.mr_group = i_mr_group
                       AND pem.table_name || pec.comment_type IS NOT NULL
                     ORDER BY pejl.line_number)
      LOOP
         l_tab(i_buf.perjl_rid) := 'PRE_ETL_RELATED_JSON_LINES';
         -- equally we can only delete associates from the relationship group if there is 
         -- only 1 entry in the group
         IF i_buf.count_in_group = 1
         THEN
            IF i_buf.pec_rid IS NOT NULL
            THEN
               l_tab(i_buf.pec_rid) := 'PRE_ETL_COMMENTS';
            END IF;
            IF i_buf.pem_rid IS NOT NULL
            THEN
               l_tab(i_buf.pem_rid) := 'PRE_ETL_MAPPED';
            END IF;
         END IF;
      END LOOP;
      --
      l_idx := l_tab.FIRST;
      WHILE l_idx IS NOT NULL
      LOOP
         CASE l_tab(l_idx)
            WHEN 'PRE_ETL_RELATED_JSON_LINES' THEN
               DELETE FROM pre_etl_related_json_lines
                WHERE ROWID = chartorowid(l_idx);
            WHEN 'PRE_ETL_COMMENTS' THEN
               DELETE FROM pre_etl_comments
                WHERE ROWID = chartorowid(l_idx);
            WHEN 'PRE_ETL_MAPPED' THEN
               DELETE FROM pre_etl_mapped
                WHERE ROWID = chartorowid(l_idx);
         END CASE;
         l_idx := l_tab.next(l_idx);
      END LOOP;
   END pr_clear_mappings_for_doc;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_json_cache IS
   BEGIN
      -- Note : If you are clearing the cache and its still responding with the 
      --        cached result.. have a look at your use of the payload HASH... 
      --        its likely that is running first...
      g_tab_json_perf_cache.delete;
      g_tab_json_smart_cache.delete;
      g_cache_pem.delete;
      g_cache_find_swap.delete;
      g_tab_of_t_tab_pejl.delete;
      g_tab_mapped_cache.delete;
      g_cache_ctx.delete;
   END pr_clear_json_cache;

   ----------------------------------------------------------------------------

   PROCEDURE pr_populate_find_swap_cache(i_introspect_step IN VARCHAR2 DEFAULT NULL) IS
      const_intro_pop_fs_cache CONSTANT VARCHAR2(30) := 'find/swap cache population'; /* Monitor the occasional find/swap cache population. */
   BEGIN
      IF g_cache_find_swap.COUNT = 0
      THEN
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => 'Any'
                                                       ,i_aspect_being_monitored => const_intro_pop_fs_cache
                                                       ,i_mode                   => 'START');
         --
         SELECT pefs.find_value
               ,pefs.swap_value
               ,pefs.use_case
           BULK COLLECT
           INTO g_cache_find_swap
           FROM pre_etl_find_swap pefs
          ORDER BY length(find_value) DESC
                  ,find_value;
         --
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => 'Any'
                                                       ,i_aspect_being_monitored => const_intro_pop_fs_cache
                                                       ,i_mode                   => 'END');
      END IF;
   END pr_populate_find_swap_cache;

   ----------------------------------------------------------------------------

   PROCEDURE pr_populate_ctx_value_cache(i_introspect_step IN VARCHAR2 DEFAULT NULL) IS
      const_intro_pop_ctx_val_cache CONSTANT VARCHAR2(30) := 'ctx value cache population'; /* Monitor the occasional context cache population. */
   BEGIN
      IF g_cache_ctx.COUNT = 0
      THEN
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => 'Any'
                                                       ,i_aspect_being_monitored => const_intro_pop_ctx_val_cache
                                                       ,i_mode                   => 'START');
         --
         FOR i_buf IN (SELECT attribute
                             ,VALUE
                         FROM gv$globalcontext a
                        WHERE a.namespace = 'MIGRATION_CONTEXT')
         LOOP
            g_cache_ctx(i_buf.attribute) := i_buf.value;
         END LOOP;
         --
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => 'Any'
                                                       ,i_aspect_being_monitored => const_intro_pop_ctx_val_cache
                                                       ,i_mode                   => 'END');
      END IF;
   END pr_populate_ctx_value_cache;
   ----------------------------------------------------------------------------

   PROCEDURE pr_populate_pem_cache(i_introspect_step IN VARCHAR2 DEFAULT NULL) IS
      l_rec_pem r_rec_pem;
      const_intro_pop_pem_cache CONSTANT VARCHAR2(30) := 'pem cache population'; /* Monitor the occasional pem cache population. */
   BEGIN
      -- We cache this to reduce SQL/PLSQL context switching in fn_get_mapping_col_or_value.
      IF g_cache_pem.COUNT = 0
      THEN
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => 'Any'
                                                       ,i_aspect_being_monitored => const_intro_pop_pem_cache
                                                       ,i_mode                   => 'START');
         FOR i_buf IN (SELECT pem.relationship_group_id
                             ,pem.mr_group
                             ,pem.table_name
                             ,pem.column_name
                             ,row_number() over(PARTITION BY pem.relationship_group_id, pem.mr_group ORDER BY pem.column_name DESC) rn
                             ,COUNT(*) over(PARTITION BY pem.relationship_group_id, pem.mr_group) cnt
                         FROM pre_etl_mapped pem
                         JOIN pre_etl_db2_columns pedc
                           ON (pedc.table_name = pem.table_name AND
                              pedc.column_name = pem.column_name)
                        ORDER BY pem.relationship_group_id
                                ,pem.mr_group
                                ,pem.column_name DESC)
         LOOP
            l_rec_pem.table_name := i_buf.table_name;
            l_rec_pem.column_name := i_buf.column_name;
            l_rec_pem.cnt := i_buf.cnt;
            g_cache_pem(i_buf.relationship_group_id || '/' || i_buf.mr_group || '/' || i_buf.rn) := l_rec_pem;
         END LOOP;
         pkg_pre_etl_utilities.pr_introspect_monitoring(i_introspect_step        => i_introspect_step
                                                       ,i_introspect_context     => 'Any'
                                                       ,i_aspect_being_monitored => const_intro_pop_pem_cache
                                                       ,i_mode                   => 'END');
      END IF;
   END pr_populate_pem_cache;

   ----------------------------------------------------------------------------

   PROCEDURE pr_reset_seq
   (
      i_sequence_name   IN VARCHAR2
     ,i_sequence_owner  IN VARCHAR2 DEFAULT USER
     ,i_based_on_table  IN VARCHAR2
     ,i_based_on_schema IN VARCHAR2 DEFAULT USER
     ,i_based_on_column IN VARCHAR2
   ) IS
      l_extended_log      VARCHAR2(32767);
      l_max               NUMBER;
      l_dummy             NUMBER;
      l_increment_by      NUMBER;
      l_reverse_seq_value NUMBER;
      l_stage             VARCHAR2(200);
      l_sequence_owner    VARCHAR2(30) := fn_contextualize(i_subject => i_sequence_owner
                                                          ,i_context => fn_get_context_value(i_attr => migration_run_framework.fn_ctx_run_context));
      l_based_on_schema   VARCHAR2(30) := fn_contextualize(i_subject => i_based_on_schema
                                                          ,i_context => fn_get_context_value(i_attr => migration_run_framework.fn_ctx_run_context));
      TYPE t_tab IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
      l_commands t_tab;
      --
      PROCEDURE pr_build_reset_seq_log IS
      BEGIN
         l_extended_log := NULL;
         IF l_commands.COUNT > 0
         THEN
            FOR i IN l_commands.FIRST .. l_commands.LAST
            LOOP
               l_extended_log := l_extended_log || l_commands(i) ||
                                 fn_lf || fn_lf;
            END LOOP;
         END IF;
      END pr_build_reset_seq_log;
   
   BEGIN
      migration_run_framework.pr_log(i_log_type  => migration_run_framework.fn_info
                                    ,i_log_entry => 'Resetting Sequence : ' ||
                                                    l_sequence_owner || '.' ||
                                                    i_sequence_name);
   
      l_stage := 'Getting Max...';
      l_commands(l_commands.COUNT + 1) := 'SELECT nvl(max(' ||
                                          i_based_on_column ||
                                          '),1) FROM ' ||
                                          l_based_on_schema || '.' ||
                                          i_based_on_table;
      EXECUTE IMMEDIATE l_commands(l_commands.COUNT)
         INTO l_max;
      --
      l_stage := 'Getting Increment By...';
      SELECT increment_by
        INTO l_increment_by
        FROM all_sequences
       WHERE sequence_name = upper(i_sequence_name)
         AND sequence_owner = upper(l_sequence_owner);
   
      l_stage := 'Getting Initial NextVal...';
      l_commands(l_commands.COUNT + 1) := 'SELECT ' ||
                                          l_sequence_owner || '.' ||
                                          i_sequence_name ||
                                          '.nextval FROM DUAL';
      EXECUTE IMMEDIATE l_commands(l_commands.COUNT)
         INTO l_reverse_seq_value;
   
      IF l_reverse_seq_value = 1
      THEN
         -- If the l_reverse_seq_value is = 1 then its a totally new sequence.
         -- if the next increment takes us over the max in the table then do nothing.
         IF l_increment_by >= l_max
         THEN
            RETURN;
         END IF;
      ELSE
         l_stage := 'Altering Sequence to decrement by the full amount (less 1)...';
         l_commands(l_commands.COUNT + 1) := 'ALTER SEQUENCE ' ||
                                             l_sequence_owner || '.' ||
                                             i_sequence_name ||
                                             ' INCREMENT BY ' ||
                                             to_char((l_reverse_seq_value * -1) + 1); /* 1 less than the full amount */
         EXECUTE IMMEDIATE l_commands(l_commands.COUNT);
         l_stage := 'Decrementing...';
         l_commands(l_commands.COUNT + 1) := 'SELECT ' ||
                                             l_sequence_owner || '.' ||
                                             i_sequence_name ||
                                             '.nextval FROM DUAL';
         EXECUTE IMMEDIATE l_commands(l_commands.COUNT)
            INTO l_dummy;
      END IF;
   
      l_stage := 'Altering Sequence to Increment by the max...';
      l_commands(l_commands.COUNT + 1) := 'ALTER SEQUENCE ' ||
                                          l_sequence_owner || '.' ||
                                          i_sequence_name ||
                                          ' INCREMENT BY ' ||
                                          to_char(greatest((l_max -
                                                           l_increment_by)
                                                          ,1));
      EXECUTE IMMEDIATE l_commands(l_commands.COUNT);
      l_stage := 'Incrementing...';
      l_commands(l_commands.COUNT + 1) := 'SELECT ' ||
                                          l_sequence_owner || '.' ||
                                          i_sequence_name ||
                                          '.nextval FROM DUAL';
      EXECUTE IMMEDIATE l_commands(l_commands.COUNT)
         INTO l_dummy;
      l_stage := 'Altering sequence to increment by the original incrementer (' ||
                 to_char(l_increment_by) || ')...';
      l_commands(l_commands.COUNT + 1) := 'ALTER SEQUENCE ' ||
                                          l_sequence_owner || '.' ||
                                          i_sequence_name ||
                                          ' INCREMENT BY ' ||
                                          to_char(l_increment_by);
      EXECUTE IMMEDIATE l_commands(l_commands.COUNT);
   
      l_stage := 'Incrementing...';
      l_commands(l_commands.COUNT + 1) := 'SELECT ' ||
                                          l_sequence_owner || '.' ||
                                          i_sequence_name ||
                                          '.nextval FROM DUAL';
      EXECUTE IMMEDIATE l_commands(l_commands.COUNT)
         INTO l_dummy;
      --
      pr_build_reset_seq_log;
      migration_run_framework.pr_log(i_log_type          => migration_run_framework.fn_info
                                    ,i_log_entry         => 'Sequence reset instructions : ' ||
                                                            l_sequence_owner || '.' ||
                                                            i_sequence_name
                                    ,i_log_extended_info => l_extended_log);
      --
   EXCEPTION
      WHEN OTHERS THEN
         --
         pr_build_reset_seq_log;
         migration_run_framework.pr_log(i_log_type          => migration_run_framework.fn_error
                                       ,i_log_entry         => 'Failed to reset sequence @ stage ' ||
                                                               l_stage ||
                                                               ' : ' ||
                                                               l_sequence_owner || '.' ||
                                                               i_sequence_name ||
                                                               ' : ' ||
                                                               SQLERRM
                                       ,i_log_extended_info => l_extended_log);
         RAISE;
   END pr_reset_seq;

   ----------------------------------------------------------------------------

   PROCEDURE pr_get_search_results
   (
      i_search_string IN VARCHAR2
     ,o_ref_cursor    OUT SYS_REFCURSOR
   ) IS
   BEGIN
      OPEN o_ref_cursor FOR
         WITH search_string AS
          (SELECT upper('%' || i_search_string || '%') search_string
             FROM dual)
         SELECT DISTINCT 'CODE/COMMENT' AS TYPE
                        ,substr(TRIM(CAST(pec.comments AS
                                          VARCHAR2(32000)))
                               ,1
                               ,2000) AS content
                        ,'Document : ' || '( ' ||
                         initcap(pejd.document_type) || ' ) ' || '/' ||
                         perjl.document_name || ' @Line : ' ||
                         perjl.line_number AS found_at
                        ,pec.comment_type AS comment_type
                        ,pejd.document_type AS document_type
                        ,perjl.document_name AS document_name
                        ,to_char(perjl.line_number) AS line_number
                        ,perjl.mr_group AS map_rules_group
                        ,pkg_pre_etl_utilities.fn_get_hash_for_clob(i_clob => pec.relationship_group_id || '-' ||
                                                                              pec.comments) AS hash_value
           FROM pre_etl_comments pec
           JOIN pre_etl_related_json_lines perjl
             ON (perjl.relationship_group_id =
                pec.relationship_group_id AND
                perjl.mr_group = pec.mr_group)
           JOIN pre_etl_json_document pejd
             ON (pejd.document_name = perjl.document_name)
          WHERE upper(pec.comments) LIKE
                (SELECT search_string FROM search_string)
          ESCAPE '\'
         UNION
         SELECT DISTINCT 'TARGET DOCUMENT' AS TYPE
                        ,TRIM(pejl.json_line) AS content
                        ,'Document : ' || '( ' ||
                          initcap(pejd.document_type) || ' ) ' || '/' ||
                          pejl.document_name || ' @Line : ' ||
                          pejl.line_number AS found_at
                        ,NULL AS comment_type
                        ,pejd.document_type AS document_type
                        ,pejl.document_name AS document_name
                        ,to_char(pejl.line_number) AS line_number
                        ,'Not Applicable' AS map_rules_group
                        ,NULL AS hash_value
           FROM pre_etl_json_lines pejl
           JOIN pre_etl_json_document pejd
             ON (pejd.document_name = pejl.document_name)
          WHERE upper(pejl.json_line) LIKE
          (SELECT search_string FROM search_string) ESCAPE '\'
         UNION
         SELECT DISTINCT 'MIGRATION' AS TYPE
                        ,'Step : ' ||
                           lpad(to_char(pemh.order_of_exec), 4, '0') ||
                           ' - Migration : ' ||
                           decode(pemh.header_type
                                 ,'P'
                                 ,'Procedural Step'
                                 ,'M'
                                 ,'Migration'
                                 ,'Unknown') || ' ( ' ||
                           initcap(pemh.migration_name) || ' ) ' AS content
                        ,substr(TRIM(CAST(substr(pemh.executable_statement
                                                  ,1
                                                  ,32000) AS
                                            VARCHAR2(32000)))
                                 ,1
                                 ,2000) AS found_at
                        ,pemh.header_type AS comment_type
                        ,pemh.header_type AS document_type
                        ,pemh.migration_group AS document_name
                        ,pemh.migration_name AS line_number
                        ,pemh.migration_group AS map_rules_group
                        ,NULL AS hash_value
           FROM pre_etl_migration_header pemh
           LEFT JOIN pre_etl_migration_detail pemd
             ON (pemd.migration_group = pemh.migration_group AND
          pemd.migration_name = pemh.migration_name)
           LEFT JOIN pre_etl_migration_src pems
             ON (pems.migration_group = pemh.migration_group AND
          pems.migration_name = pemh.migration_name)
          WHERE (upper(pemh.staged_schema) LIKE
          (SELECT search_string FROM search_string) ESCAPE
           '\' OR upper(pemh.executable_statement) LIKE
           (SELECT search_string FROM search_string) ESCAPE
           '\' OR upper(pemd.migration_document) LIKE
           (SELECT search_string FROM search_string) ESCAPE
           '\' OR upper(pems.table_name) LIKE
           (SELECT search_string FROM search_string) ESCAPE
           '\' OR upper(pems.where_or_join_predicates) LIKE
           (SELECT search_string FROM search_string) ESCAPE '\')
          ORDER BY 1
                  ,8
                  ,2;
   
   END pr_get_search_results;

   ----------------------------------------------------------------------------

   PROCEDURE pr_replace_clob
   (
      io_subject IN OUT CLOB
     ,i_replace  IN VARCHAR2
     ,i_value    IN CLOB
   ) IS
      TYPE t_varchar2_32000 IS TABLE OF VARCHAR2(32000) INDEX BY BINARY_INTEGER;
      v_varchar2_32000      t_varchar2_32000;
      v_idx_varchar2_32000  PLS_INTEGER := 0;
      v_pos                 PLS_INTEGER := 1;
      v_replace_placeholder VARCHAR2(255);
      v_len                 NUMBER;
   BEGIN
      -- If we're using a clob as the replace value, its possible that it might be
      -- over 32k in length... We need to split this appropriately as a replacement
      -- value of over 32k will throw :-
      -- "ORA-22828: input pattern or replacement parameters exceed 32K size limit"
      WHILE TRUE
      LOOP
         v_varchar2_32000(v_idx_varchar2_32000) := substr(i_value
                                                         ,v_pos
                                                         ,31000);
         v_len := length(v_varchar2_32000(v_idx_varchar2_32000));
         IF v_len IS NULL
            OR v_len < 31000
         THEN
            EXIT;
         END IF;
         --
         -- Add on to the end of the line a replacement tag (should be <xyz_?> where xyz is the i_replace
         -- and ? is a number)
         v_varchar2_32000(v_idx_varchar2_32000) := v_varchar2_32000(v_idx_varchar2_32000) ||
                                                   substr(i_replace
                                                         ,1
                                                         ,length(i_replace) - 1) || '_' ||
                                                   TRIM(to_char(v_idx_varchar2_32000 + 1)) ||
                                                   substr(i_replace
                                                         ,length(i_replace)
                                                         ,1);
         v_idx_varchar2_32000 := v_idx_varchar2_32000 + 1;
         v_pos := v_pos + 31000;
      END LOOP;
   
      IF v_varchar2_32000.COUNT > 0
      THEN
         FOR i IN v_varchar2_32000.FIRST .. v_varchar2_32000.LAST
         LOOP
            IF i = 0
            THEN
               v_replace_placeholder := i_replace;
            ELSE
               v_replace_placeholder := substr(i_replace
                                              ,1
                                              ,length(i_replace) - 1) || '_' ||
                                        TRIM(to_char(i)) ||
                                        substr(i_replace
                                              ,length(i_replace)
                                              ,1);
            END IF;
            io_subject := REPLACE(io_subject
                                 ,v_replace_placeholder
                                 ,v_varchar2_32000(i));
         END LOOP;
      END IF;
   
   END pr_replace_clob;
   --
   --
   --
   PROCEDURE pr_replace_varchar2
   (
      io_subject IN OUT VARCHAR2
     ,i_replace  IN VARCHAR2
     ,i_value    IN VARCHAR2
   ) IS
   BEGIN
      io_subject := REPLACE(io_subject, i_replace, i_value);
   END pr_replace_varchar2;

   ----------------------------------------------------------------------------
   PROCEDURE pr_write_relationship_comment
   (
      i_mode                  IN VARCHAR2
     ,i_mr_group              IN VARCHAR2
     ,i_relationship_group_id IN NUMBER
     ,i_comment_type          IN VARCHAR2
     ,i_comments              IN VARCHAR2
     ,o_sqlrowcount           OUT NUMBER
   ) IS
   BEGIN
      IF i_mode NOT IN ('INSERT', 'UPDATE', 'DELETE')
      THEN
         raise_application_error(-20000
                                ,'pkg_pre_etl_tools.pr_write_relationship_comment : Unknown mode (' ||
                                 i_mode || ')');
      END IF;
      --
      IF i_mode = 'DELETE'
      THEN
         DELETE FROM pre_etl_comments
          WHERE relationship_group_id = i_relationship_group_id
            AND mr_group = i_mr_group
            AND comment_type LIKE i_comment_type;
         o_sqlrowcount := SQL%ROWCOUNT;
      ELSIF i_mode = 'UPDATE'
      THEN
         IF i_comment_type IN ('A', 'V')
         THEN
            UPDATE pre_etl_comments
               SET comments     = rtrim(rtrim(i_comments, chr(13))
                                       ,chr(10))
                  ,comment_type = i_comment_type
             WHERE relationship_group_id = i_relationship_group_id
               AND mr_group = i_mr_group
               AND decode(comment_type, 'V', 'A', comment_type) =
                   decode(i_comment_type, 'V', 'A', i_comment_type);
         ELSE
            UPDATE pre_etl_comments
               SET comments = rtrim(rtrim(i_comments, chr(13))
                                   ,chr(10))
             WHERE relationship_group_id = i_relationship_group_id
               AND mr_group = i_mr_group
               AND comment_type = i_comment_type;
         END IF;
         o_sqlrowcount := SQL%ROWCOUNT;
      ELSIF i_mode = 'INSERT'
      THEN
         INSERT INTO pre_etl_comments
            (mr_group
            ,relationship_group_id
            ,comment_type
            ,comments)
         VALUES
            (i_mr_group
            ,i_relationship_group_id
            ,i_comment_type
            ,rtrim(rtrim(i_comments, chr(13)), chr(10)));
         o_sqlrowcount := SQL%ROWCOUNT;
      END IF;
      --
   END pr_write_relationship_comment;
   ----------------------------------------------------------------------------

   PROCEDURE pr_add_context_association
   (
      i_json_document IN VARCHAR2
     ,i_context_name  IN VARCHAR2
   ) IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      INSERT INTO pre_etl_doc_valid_contexts
         (document_name
         ,context_name)
      VALUES
         (i_json_document
         ,i_context_name);
      COMMIT;
   EXCEPTION
      WHEN dup_val_on_index THEN
         NULL;
   END pr_add_context_association;

   ----------------------------------------------------------------------------

   PROCEDURE pr_remove_context_association
   (
      i_json_document IN VARCHAR2
     ,i_context_name  IN VARCHAR2
   ) IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      DELETE FROM pre_etl_doc_valid_contexts pedvc
       WHERE pedvc.document_name = i_json_document
         AND pedvc.context_name = i_context_name;
      COMMIT;
   END pr_remove_context_association;

   ----------------------------------------------------------------------------

   PROCEDURE pr_open_popup_cur
   (
      i_sql    IN VARCHAR2
     ,i_handle IN NUMBER
   ) IS
      l_sys_refcursor SYS_REFCURSOR;
      l_count         PLS_INTEGER := 0;
   BEGIN
      IF NOT g_popup_tab.EXISTS(i_handle)
      THEN
         OPEN l_sys_refcursor FOR i_sql;
         LOOP
            l_count := l_count + 1;
            FETCH l_sys_refcursor
               INTO g_popup_tab(i_handle)(l_count);
            EXIT WHEN l_sys_refcursor%NOTFOUND;
         END LOOP;
      END IF;
   END pr_open_popup_cur;

   ----------------------------------------------------------------------------

   PROCEDURE pr_fetch_popup_cur
   (
      i_index        IN NUMBER
     ,i_handle       IN NUMBER
     ,o_shown        OUT VARCHAR2
     ,o_actual       OUT VARCHAR2
     ,o_no_data_bool OUT BOOLEAN
   ) IS
   BEGIN
      IF g_popup_tab.EXISTS(i_handle)
      THEN
         IF g_popup_tab(i_handle).COUNT > 0
         THEN
            IF g_popup_tab(i_handle).EXISTS(i_index)
            THEN
               o_shown  := g_popup_tab(i_handle)(i_index).shown_value;
               o_actual := g_popup_tab(i_handle)(i_index)
                          .actual_value;
            ELSE
               o_no_data_bool := TRUE;
            END IF;
         ELSE
            o_no_data_bool := TRUE;
         END IF;
      ELSE
         o_no_data_bool := TRUE;
      END IF;
   END pr_fetch_popup_cur;

   ----------------------------------------------------------------------------

   PROCEDURE pr_clear_cached_popups IS
   BEGIN
      g_popup_tab.delete;
   END pr_clear_cached_popups;

   ----------------------------------------------------------------------------

   PROCEDURE pr_add_tables_to_mapping_tool
   (
      i_owner_name                  IN VARCHAR2
     ,i_single_table_name           IN VARCHAR2 DEFAULT NULL
     ,i_tableset_name               IN VARCHAR2
     ,i_delete_existing_in_set_bool IN BOOLEAN DEFAULT FALSE
   ) IS
   BEGIN
      IF i_delete_existing_in_set_bool
      THEN
         DELETE FROM pre_etl_db2_columns d
          WHERE d.tableset_name = i_tableset_name
            AND d.table_name = nvl(i_single_table_name, d.table_name);
      
         DELETE FROM pre_etl_db2_tables d
          WHERE d.tableset_name = i_tableset_name
            AND d.table_name = nvl(i_single_table_name, d.table_name);
      END IF;
      --
      INSERT INTO pre_etl_db2_columns
         (table_name
         ,column_pos
         ,column_name
         ,column_type
         ,column_length
         ,comments
         ,tableset_name)
         SELECT dtc.table_name AS table_name
               ,(dtc.column_id - 1) column_pos
               ,dtc.column_name AS column_name
               ,dtc.data_type AS column_type
               ,(CASE dtc.data_type
                   WHEN 'CHAR' THEN
                    dtc.char_length
                   WHEN 'VARCHAR2' THEN
                    dtc.char_length
                   ELSE
                    dtc.data_length
                END) AS column_length
               ,dcc.comments AS comments
               ,i_tableset_name
           FROM dba_tab_cols dtc
           LEFT JOIN dba_col_comments dcc
             ON (dcc.owner = dtc.owner AND
                dcc.table_name = dtc.table_name AND
                dcc.column_name = dtc.column_name)
          WHERE dtc.owner = upper(i_owner_name)
            AND dtc.table_name =
                nvl(upper(i_single_table_name), dtc.table_name)
            AND dtc.column_name NOT IN
                ('MIGRATION_BATCH_ID', 'MIGRATION_STATUS')
            AND dtc.hidden_column = 'NO'
            AND dtc.table_name NOT LIKE 'BIN$%'
         UNION
         SELECT dtc.table_name
               ,-1
               ,'<Not Mapped>'
               ,'0'
               ,0
               ,'JSON needs Mapping...'
               ,i_tableset_name
           FROM dba_tab_cols dtc
          WHERE dtc.owner = upper(i_owner_name)
            AND dtc.table_name =
                nvl(upper(i_single_table_name), dtc.table_name)
            AND dtc.table_name NOT LIKE 'BIN$%';
      --                  
      INSERT INTO pre_etl_db2_tables
         (table_name
         ,markit_comment
         ,description
         ,local_hash
         ,tableset_name)
         SELECT DISTINCT d.table_name
                        ,NULL
                        ,(SELECT dtc.comments
                           FROM dba_tab_comments dtc
                          WHERE dtc.owner = i_owner_name
                            AND dtc.table_name = d.table_name
                            AND rownum = 1)
                        ,NULL
                        ,i_tableset_name
           FROM pre_etl_db2_columns d
          WHERE d.tableset_name = i_tableset_name
            AND d.table_name =
                nvl(upper(i_single_table_name), d.table_name);
      COMMIT;
   EXCEPTION
      WHEN dup_val_on_index THEN
         ROLLBACK;
         raise_application_error(-20000
                                ,(CASE WHEN
                                  i_single_table_name IS NULL THEN
                                  'A table in the schema being added already exists (possibly under another tableset name). Check your schema/owner name.' ELSE
                                  'The table being added already exists (possibly under another tableset name). Check your schema/owner name.' END));
      WHEN OTHERS THEN
         ROLLBACK;
         RAISE;
   END pr_add_tables_to_mapping_tool;

   ----------------------------------------------------------------------------
   PROCEDURE pr_add_schema_to_mapping_tool
   (
      i_schema_name                 IN VARCHAR2
     ,i_tableset_name               IN VARCHAR2
     ,i_delete_existing_in_set_bool IN BOOLEAN DEFAULT FALSE
   ) IS
   BEGIN
      pr_add_tables_to_mapping_tool(i_owner_name                  => i_schema_name
                                   ,i_tableset_name               => nvl(i_tableset_name
                                                                        ,'UNNAMED')
                                   ,i_delete_existing_in_set_bool => i_delete_existing_in_set_bool);
   END pr_add_schema_to_mapping_tool;
   ----------------------------------------------------------------------------

   PROCEDURE pr_add_table_to_mapping_tool
   (
      i_owner_name                  IN VARCHAR2
     ,i_table_name                  IN VARCHAR2
     ,i_tableset_name               IN VARCHAR2
     ,i_delete_existing_in_set_bool IN BOOLEAN DEFAULT FALSE
   ) IS
   BEGIN
      IF i_table_name IS NULL
      THEN
         raise_application_error(-20000
                                ,'i_table_name must be supplied.');
      END IF;
      pr_add_tables_to_mapping_tool(i_owner_name                  => i_owner_name
                                   ,i_single_table_name           => i_table_name
                                   ,i_tableset_name               => nvl(i_tableset_name
                                                                        ,'UNNAMED')
                                   ,i_delete_existing_in_set_bool => i_delete_existing_in_set_bool);
   END pr_add_table_to_mapping_tool;
END pkg_pre_etl_tools;
/
